// This file is auto-generated by @hey-api/openapi-ts

/**
 * InferredReference is an object with a single `id` property that is used to reference another object. The type of
 * entity being referenced is inferred from the context in which the reference is used.
 *
 */
export type InferredReference = {
    id: string;
};

/**
 * CreateHubConnectionTemplate defines the request body for creating a new Hub Connector
 */
export type HubConnectionTemplateCreate = {
    authSchemeConfig: AuthSchemeConfig;
    /**
     * ConnectorID is the unique identifier of the Connector that the Hub Connector is wrapping.
     *
     */
    connectorId: string;
};

/**
 * HubMetadata is used to define metadata for a hub.
 */
export type IntegrationMetadata = {
    usedConnectionTemplates?: Array<(string)>;
};

/**
 * HubConnectorVariable is a variable that can be used to customise the behaviour of the connector.
 *
 * Variables are stored on the Connector and signal the defaults to use when connecting. The user can override
 * these defaults when connecting to the connector.
 *
 */
export type HubConnectorVariable = {
    /**
     * Name defines the variable name being configured.
     *
     */
    name: string;
    /**
     * Value defines the value of the variable, this may be any valid JSON value.
     *
     */
    value: unknown;
    /**
     * Label is a human-friendly name for the variable. This is used to display the variable to the end user when
     * they are connecting to the connector.
     *
     */
    label?: string;
    /**
     * Description allows for a longer description of what this variable is used for. This may be shown to the end
     * user when they are connecting to the connector in the form of a tooltip or expandable info view.
     *
     */
    description?: unknown;
    /**
     * Required indicates whether the variable is required when connecting to the connector. If the variable is
     * required, the user must provide a value for the variable when connecting.
     *
     */
    required?: boolean;
};

/**
 * A Hub Connection Template is a lightweight wrapper around a Connector from Connect API, but includes additional
 * information to make embedding the integration simpler.
 *
 * Versori-users do not need to establish connections in an integration. These are connected to
 * by end-users when they activate the integration from the embedded integration hub.
 *
 */
export type HubConnectionTemplate = {
    /**
     * ID is the unique identifier of the Hub Connection Template.
     */
    id: string;
    /**
     * ConnectorID is the unique identifier of the Connector.
     */
    connectorId: string;
    /**
     * ImageURL is a URL to an image/icon that represents the connector. This image is used within the
     * integration tile displayed in the embedded UI.
     *
     */
    imageUrl: string;
    /**
     * name denotes the name of the Connector that the template is wrapping.
     *
     */
    name: string;
    /**
     * IsUsed indicates that this connection template is in use by the hub.
     */
    isUsed: boolean;
    /**
     * IsPrimary indicates that this is the primary connections on the hub.
     */
    isPrimary: boolean;
    authSchemeConfig: AuthSchemeConfig;
};

/**
 * A Hub Connection Template is a lightweight wrapper around a Connector from Connect API, but includes additional
 * information to make embedding the integration simpler.
 *
 * Versori-users do not need to establish connections in an integration. These are connected to
 * by end-users when they activate the integration from the embedded integration hub.
 *
 */
export type ConnectorInfo = {
    /**
     * ID is the unique identifier of the Hub Connector.
     */
    connectorId: string;
    /**
     * name denotes the name of the Connector that the template is wrapping.
     *
     */
    name: string;
    authSchemeConfig: AuthSchemeConfig;
    /**
     * ImageURL is a URL to an image/icon that represents the integration. This image is used within the integration
     * tile displayed in the embedded UI.
     *
     */
    imageUrl: string;
    variables: ActivationVariables;
};

/**
 * HubConnectionTemplatePage is a paginated list of Hub Connection Templates.
 *
 */
export type HubConnectionTemplatePage = PageInfo & {
    connectionTemplates: Array<HubConnectionTemplate>;
};

export type EndUser = {
    /**
     * ID is the Versori identifier for the user. Most APIs will not use this field but instead reference
     * users by their externalId.
     *
     */
    id: string;
    /**
     * ExternalID is the identifier for the user as determined by the organisation. This typically should
     * be the same as the user's ID on the Primary Connector for the Hub. Regardless of the value, it must
     * be unique within the Hub.
     *
     */
    externalId: string;
    /**
     * DisplayName is an optional human-readable name for the user. If not set, the default is an empty string.
     *
     */
    displayName: string;
    /**
     * The hub ID to which the user belongs to.
     */
    hubId: string;
    /**
     * PrimaryConnection is the connection that the user will use to authenticate to the primary connector.
     *
     */
    primaryConnection: Connection;
    /**
     * CreatedAt is the time the user was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time the user was last updated.
     */
    updatedAt: string;
};

export type EndUserSummary = {
    /**
     * ID is the Versori identifier for the user. Most APIs will not use this field but instead reference
     * users by their externalId.
     *
     */
    id: string;
    /**
     * ExternalID is the identifier for the user as determined by the organisation. This typically should
     * be the same as the user's ID on the Primary Connector for the Hub. Regardless of the value, it must
     * be unique within the Hub.
     *
     */
    externalId: string;
    /**
     * DisplayName is an optional human-readable name for the user. If not set, the default is an empty string.
     *
     */
    displayName: string;
    /**
     * The hub ID to which the user belongs to.
     */
    hubId: string;
    /**
     * CreatedAt is the time the user was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time the user was last updated.
     */
    updatedAt: string;
};

export type ListIntegrations = {
    /**
     * Total integrations for the given Hub
     */
    total: number;
    integrations: Array<Integration>;
};

/**
 * Request to create a new Integration - updatedAt
 */
export type CreateIntegrationRequest = unknown;

/**
 * ConnectorConnectionPage defines a page of Connection summaries.
 */
export type EndUserConnectionsPage = PageInfo & {
    connections?: Array<ConnectionSummary>;
};

/**
 * Request to create a new End User
 */
export type EndUserCreate = {
    /**
     * ExternalID is the identifier of the user as identified in the Hub's primary connector/system.
     */
    externalId: string;
    /**
     * DisplayName is a human-readable name for the user
     */
    displayName?: string;
    /**
     * PrimaryConnection is the connection that the user will use to authenticate to the primary connector.
     *
     */
    primaryConnection: ConnectionCreate;
};

export type EndUserPage = PageInfo & {
    users: Array<EndUserSummary>;
};

/**
 * IntegrationCreate contains the payload to create a new Embedded Integration.
 *
 */
export type IntegrationCreate = {
    connectionTemplate?: HubConnectionTemplateCreate;
    /**
     * Short description of the Integration
     */
    description?: string;
    /**
     * The summary of the Integration
     */
    summary?: string;
    /**
     * The name of the Integration
     */
    name: string;
    organisationId: string;
};

/**
 * Integration represents an embedded integration that can be activated by end users.
 *
 */
export type Integration = {
    id: string;
    /**
     * Name is a short name for the integration, this is typically the name of the Connector being integrated to.
     *
     */
    name: string;
    /**
     * ImageURL is a URL to an image/icon that represents the integration. This image is used within the
     * integration tile displayed in the embedded UI.
     *
     */
    imageUrl?: string;
    /**
     * Description can be used to provide a longer description of the integration. This can be shown to end users
     * in the embedded integration hub UI.
     *
     */
    description?: string;
    /**
     * BoardID is a reference to underlying board that configures the integration.
     *
     * For more information on boards see Switchboard API.
     *
     */
    boardId: string;
};

/**
 * IntegrationPage is a paginated list of integrations.
 *
 */
export type IntegrationPage = PageInfo & {
    integrations: Array<Integration>;
};

/**
 * CreateHubRequest is the payload to create a new Hub.
 *
 */
export type HubCreate = {
    /**
     * The ID of the organisation that the Hub belongs to
     */
    organisationId: string;
    /**
     * The name of the Hub
     */
    name: string;
    /**
     * PrimaryConnectorID references the Connector that the Hub will be built around.
     *
     */
    primaryConnectorId: string;
    /**
     * AuthSchemeConfig defines how your End Users should authenticate to the primary connector.
     *
     * This is used to drive the front-end experience for the end user, however any authentication scheme
     * config can be used when connecting to a connector over the API.
     *
     */
    authSchemeConfig: AuthSchemeConfig;
};

/**
 * A Hub description
 */
export type Hub = {
    /**
     * The ID of the Hub
     */
    id: string;
    /**
     * The name of the Hub
     */
    name: string;
    /**
     * PrimaryConnector is the connector that the Hub is built around.
     *
     */
    primaryConnector: ConnectorInfo;
};

/**
 * HubsPage contains a list of hubs using Versori's pagination response types. Initially the ListHubs endpoint
 * will return all hubs, but this is subject to change in the future and may become paginated.
 *
 */
export type HubsPage = PageInfo & {
    hubs: Array<Hub>;
};

/**
 * EmbeddedIntegration represents an integration that is available to an end user and contains all the necessary
 * information for the UI to determine how the user should activate the integration.
 *
 */
export type EmbeddedIntegration = {
    /**
     * ID is the unique identifier for the Integration
     */
    id: ULID;
    /**
     * Name is a short name for the integration, this is typically the name of the Connector being integrated to.
     *
     */
    name: string;
    /**
     * ImageURL is a URL to an image/icon that represents the integration. This image is used within the integration
     * tile displayed in the embedded UI.
     *
     */
    imageUrl: string;
    /**
     * Description can be used to provide a longer description of the integration. This can be shown to end users
     * in the embedded integration hub UI.
     *
     */
    description: string;
    /**
     * IsDeployed indicates whether the integration is deployed and available to end users. If not deployed, the
     * integration cannot be activated.
     *
     */
    isDeployed: boolean;
    /**
     * IsActivated indicates whether the integration is activated for the end user. If the integration is not
     * activated, the user can activate it from the embedded integration hub.
     *
     */
    isActivated: boolean;
    /**
     * ConnectionTemplates is a list of connections that the end user can authenticate to when activating the integration.
     *
     */
    connectionTemplates: Array<HubConnectionTemplate>;
};

/**
 * EndUserIntegration represents an integration that is available to an end user.
 *
 * This object is only a summary of the integration and does not contain all the information to enable the user
 * to activate it. The GetEmbeddedIntegration endpoint should be used to retrieve the full integration details.
 *
 */
export type EmbeddedIntegrationSummary = {
    id: ULID;
    /**
     * Name is a short name for the integration, this is typically the name of the Connector being integrated to.
     *
     */
    name: string;
    /**
     * ImageURL is a URL to an image/icon that represents the integration. This image is used within the
     * integration tile displayed in the embedded UI.
     *
     */
    imageUrl: string;
    /**
     * Description can be used to provide a longer description of the integration. This can be shown to end users
     * in the embedded integration hub UI.
     *
     */
    description: string;
    /**
     * IsDeployed indicates whether the integration is deployed and available to end users. If not deployed, the
     * integration cannot be activated.
     *
     */
    isDeployed: boolean;
    /**
     * IsActivated indicates whether the integration is activated for the end user. If the integration is not
     * activated, the user can activate it from the embedded integration hub.
     *
     */
    isActivated: boolean;
};

/**
 * EndUserIntegrationPage is a paginated list of integrations to be displayed to the user when embedding the
 * integration hub.
 *
 */
export type EmbeddedIntegrationPage = PageInfo & {
    integrations: Array<EmbeddedIntegrationSummary>;
    /**
     * TotalConnected is the total number of integrations that are connected for the end user. This can be used
     * to display a badge on the embedded integration hub to show the user how many integrations they have
     * connected.
     *
     */
    totalConnected?: number;
};

export type Activation = {
    id: string;
    user: EndUser;
    hubId: string;
    integration: EmbeddedIntegrationSummary;
};

/**
 * ActivationVariable is a variable that is passed to the Integration when it is activated.
 *
 */
export type ActivationVariable = {
    /**
     * Name defines the variable name being configured.
     */
    name: string;
    /**
     * Value defines the value of the variable.
     */
    value: unknown;
};

/**
 * ActivationVariables is a map of variables that are passed to the Integration when it is activated. These
 * variables are used to configure the Integration for the end user.
 *
 */
export type ActivationVariables = Array<ActivationVariable>;

/**
 * ActivationConnectionCreateNew defines a new Connection to be used in an Activation
 *
 */
export type ActivationConnectionCreateExisting = {
    /**
     * TemplateID is a reference to a Connection Template which this Activation Connection is binding to.
     *
     */
    templateId: string;
    /**
     * ID is the unique identifier of an existing Connection.
     *
     */
    connectionId: string;
};

/**
 * ActivationConnectionCreateNew defines a new Connection to be used in an Activation
 *
 */
export type ActivationConnectionCreateNew = {
    /**
     * TemplateID is a reference to a Connection Template which this Activation Connection is binding to.
     *
     */
    templateId: string;
    /**
     * Name is the name of the Connection.
     */
    name: string;
    credentials: ConnectionCredentialsCreate;
    variables: Array<ConnectionVariable>;
};

/**
 * ActivationConnectionCreate defines how an Activation Connection should be created. It may reference an existing
 * Connection belonging to this Ens User, or a new Connection can be created.
 *
 */
export type ActivationConnectionCreate = ActivationConnectionCreateExisting | ActivationConnectionCreateNew;

/**
 * ActivationCreate is the request payload to activate an Integration for End User
 *
 */
export type ActivationCreate = {
    /**
     * UserID references the user to activate the integration for, this may be their Versori identifier or their
     * external identifier, indicated by the `userIdType` field.
     *
     */
    userId: string;
    /**
     * IntegrationID references the Integration that the activation is for.
     *
     */
    integrationId: string;
    /**
     * Connections is a list of Activation Connections to create for this Activation. Each Activation Connection
     * can either reference an existing underlying Connection, or a new Connection can be created.
     *
     */
    connections: Array<ActivationConnectionCreate>;
    variables: ActivationVariables;
};

/**
 * ActivationPage is a paginated list of Activations.
 *
 */
export type ActivationPage = PageInfo & {
    activations: Array<Activation>;
};

export type ULID = string;

export type HealthResponse = {
    message?: string;
};

/**
 * ErrorField denotes a field which has an error.
 */
export type ErrorField = {
    /**
     * Field is the name of the field which has an error, this may be a path to a nested field, including array
     * elements. The format of this field is of the form: "field1.field2[0].field3"
     *
     */
    field: string;
    /**
     * Message is the error message for this specific field.
     */
    message: string;
};

export type Error = {
    /**
     * Code is a machine-readable error code.
     */
    code: string;
    /**
     * Message is a human-readable error message.
     */
    message: string;
    fields?: Array<ErrorField>;
    details?: string;
};

export type PageInfo = {
    totalCount: number;
    next?: string;
    prev?: string;
};

export type MessageSeverity = 'info' | 'warning' | 'error';

/**
 * Message is a message to be displayed to the user to indicate some information about the
 * preceding request.
 *
 */
export type Message = {
    /**
     * Text contains the text of the message.
     */
    text: string;
    severity: MessageSeverity;
    /**
     * Details contains additional information about the message. This is intended to be used
     * to provide more information about the message, such as a list of validation errors.
     *
     */
    detail?: Array<(string)>;
};

export type AuthSchemeConfigBase = {
    /**
     * ID is the unique identifier of the AuthSchemeConfig, this is generated by the client and
     * only requires to be unique amongst the elements of the array in which is it contained.
     *
     */
    id: string;
    /**
     * Description enables users to distinguish multiple configurations which use the same
     * schemeType.
     *
     */
    description: string;
    /**
     * ValidationMessages is a list of messages which are generated when the AuthSchemeConfig
     * is validated. This is typically used to provide feedback to the user when they are
     * creating or updating the AuthSchemeConfig.
     *
     * This field will be ignored if sent to the API.
     *
     */
    validationMessages?: Array<Message>;
};

/**
 * AuthSchemeConfigNone is a placeholder object with the schemeType set to `none`. There is no other configuration
 * required.
 *
 */
export type AuthSchemeConfigNone = AuthSchemeConfigBase & {
    schemeType: "none";
};

/**
 * AuthSchemeConfigAPIKeyIn defines the location of the API key in the request.
 *
 */
export type AuthSchemeConfigAPIKeyIn = 'query' | 'header' | 'cookie';

/**
 * AuthSchemeConfigAPIKey defines how a Connector uses an API key credential to authenticate with the system.
 *
 */
export type AuthSchemeConfigAPIKey = AuthSchemeConfigBase & {
    schemeType: "api-key";
    /**
     * Name is the query parameter/header/cookie name which will be used to send the API key.
     */
    name: string;
    in: AuthSchemeConfigAPIKeyIn;
};

/**
 * AuthSchemeConfigBasicAuth is a placeholder object with the schemeType set to `basic-auth`. There is no other
 * configuration required.
 *
 */
export type AuthSchemeConfigBasicAuth = AuthSchemeConfigBase & {
    schemeType: "basic-auth";
};

/**
 * OAuth2Scope represents a single scope which can be requested by an OAuth2 application.
 *
 */
export type OAuth2Scope = {
    /**
     * Name is the name of the scope as determined by the application to which this Connector
     * is connecting to.
     *
     */
    name: string;
    /**
     * Description describes the scope in human-friendly terminology. This text may be
     * displayed to users via a help tooltip or similar.
     *
     */
    description?: string;
};

/**
 * AuthSchemeConfigOAuth2GrantAuthorizationCode contains grant-specific configuration for the
 * `authorization_code` grant type.
 *
 * How the API manages changes to this configuration is as follows:
 *
 * - CredentialID and OrganisationID are not set, a new credential is created containing the
 * sensitive information and the non-sensitive information is updated in the database.
 * - Otherwise, both the credential and the database are updated using JSON Merge Patch, with
 * undefined properties not being updated.
 * - Any other permutation will result in a 400 Bad Request.
 *
 */
export type AuthSchemeConfigOAuth2GrantAuthorizationCode = {
    grantType: 'authorization_code';
    /**
     * CredentialID is the unique identifier of the Credential which contains the client ID and
     * client secret to be used as part of the `password` flow.
     *
     */
    credentialId?: string;
    /**
     * OrganisationID is the unique identifier of the Organisation that owns the Credential.
     * This can be different to the Connector's OrganisationID since some may be imported from
     * Versori's public library.
     *
     */
    organisationId?: string;
    /**
     * ClientID is the OAuth 2.0 client's identifier. This is not a sensitive value and may be
     * presented to the user in plaintext.
     *
     */
    clientId?: string;
    /**
     * ClientSecret is the OAuth 2.0 client's secret. This is a sensitive value and will not be
     * displayed to the user.
     *
     */
    clientSecret?: string;
};

export type AuthSchemeConfigOAuth2GrantClientCredentials = {
    grantType: 'client_credentials';
};

/**
 * AuthSchemeConfigOAuth2GrantPassword contains grant-specific configuration for the `password`
 * grant type.
 *
 * How the API manages changes to this configuration is as follows:
 *
 * - CredentialID and OrganisationID are not set, a new credential is created containing the
 * sensitive information and the non-sensitive information is created/updated in the
 * database.
 * - Otherwise, both the credential and the database are updated using JSON Merge Patch.
 * - Any other permutation will result in a 400 Bad Request.
 *
 */
export type AuthSchemeConfigOAuth2GrantPassword = {
    grantType: 'password';
    /**
     * CredentialID is the unique identifier of the Credential which contains the client ID and
     * client secret to be used as part of the `password` flow.
     *
     */
    credentialId?: string;
    /**
     * OrganisationID is the unique identifier of the Organisation that owns the Credential. This can be different
     * to the Connector's OrganisationID since some may be imported from Versori's public library.
     *
     */
    organisationId?: string;
    /**
     * ClientID is the OAuth 2.0 client's identifier. This is not a sensitive value and may be presented to the
     * user in plaintext.
     *
     */
    clientId?: string;
    /**
     * ClientSecret is the OAuth 2.0 client's secret. This is a sensitive value and will not be displayed to the
     * user. It may be populated when updating the Credential.
     *
     */
    clientSecret?: string;
};

export type AuthSchemeConfigOAuth2Grant = AuthSchemeConfigOAuth2GrantAuthorizationCode | AuthSchemeConfigOAuth2GrantClientCredentials | AuthSchemeConfigOAuth2GrantPassword;

/**
 * AuthSchemeConfigOAuth2 defines how a Connector uses an OAuth2 credential to authenticate
 * with the system. This is to be used for all OAuth 2.0 flows which require a client ID and
 * client secret as part of the Connector's configuration. Connectors which use the
 * `client_credentials` grant type, where the user provides the Client ID  and Client Secret at
 * the point where they connect, should use the `AuthSchemeConfigOAuth2ClientCredentials` type
 * instead.
 *
 */
export type AuthSchemeConfigOAuth2 = AuthSchemeConfigBase & {
    schemeType: "oauth2";
    /**
     * AuthorizeURL is the URL which the user will be redirected to in order to authorize
     * the application.
     *
     */
    authorizeUrl: string;
    /**
     * TokenURL is the URL which the application will use to issue an access token.
     *
     */
    tokenUrl: string;
    /**
     * Scopes is the list of all OAuth2 scopes which the application supports. The user
     * will be allowed to choose which scopes to request when configuring the Connection.
     *
     */
    scopes: Array<OAuth2Scope>;
    /**
     * DefaultScopes is the list of scopes which will be requested by default when the user
     * connects the Connector. This is useful for Connectors which require a specific set
     * of scopes to function correctly.
     *
     */
    defaultScopes: Array<(string)>;
    /**
     * AdditionalAuthorizeParams is a URL-encoded query string which should be attached to
     * the AuthorizeURL when the user is redirected to the OAuth 2.0 authorization
     * endpoint.
     *
     * This value is only used by the UI to drive the default values when connecting, the
     * API to `InitialiseOAuth2Connection` can be provided a different value if required.
     *
     */
    additionalAuthorizeParams?: string;
    /**
     * AdditionalTokenParams is a URL-encoded string following the
     * `application/x-www-form-urlencoded` mime-type, which can be used to pass additional
     * parameters to the OAuth 2.0 token endpoint within the request body.
     *
     */
    additionalTokenParams?: string;
    /**
     * MTLSEnabled is a flag which determines whether the Connector should use Mutual TLS
     * (mTLS) to authenticate with the OAuth 2.0 token endpoint. This is useful for
     * Connectors which require a higher level of security.
     *
     */
    mtlsEnabled?: boolean;
    /**
     * MTLSCredentialID is the unique identifier of the Credential which contains the
     * client certificate and private key to be used as part of the mTLS connection.
     *
     * This may be unset when creating a connection, in which case if `mtlsEnabled` is
     * true, then the API will find an associated AuthSchemeConfigCertificate and link
     * them automatically.
     *
     */
    mtlsCredentialId?: string;
    grant: AuthSchemeConfigOAuth2Grant;
};

/**
 * AuthSchemeConfigHMACIn defines where the signature should be set on requests.
 */
export type AuthSchemeConfigHMACIn = 'query' | 'header' | 'cookie';

/**
 * AuthSchemeConfigHMAC defines how a Connector uses an HMAC credential to authenticate with the system.
 *
 * This may be used on outbound requests to sign the request body, however it is more commonly used on inbound
 * requests (i.e. from Webhook Triggers) to verify the sender of the request is allowed to invoke the Trigger.
 *
 */
export type AuthSchemeConfigHMAC = AuthSchemeConfigBase & {
    schemeType: "hmac";
    /**
     * Name is the query parameter/header/cookie name which will be used to send the signature.
     */
    name: string;
    in: AuthSchemeConfigHMACIn;
    /**
     * AuthSchemeConfigHMACAlgorithm defines the hashing algorithm to use when generating the HMAC signature.
     */
    algorithm: 'sha1' | 'sha256' | 'sha512';
    /**
     * AuthSchemeConfigHMACInputs defines what parts of a HTTP request are consumed to generate the HMAC signature. Some systems
     * only generate the signature from the request body, others may include the URL. The order of this array
     * defines the order in which the input is fed into the hashing function.
     *
     */
    digestInputs: Array<('body' | 'url')>;
};

/**
 * AuthSchemeConfigHMACAlgorithm defines the hashing algorithm to use when generating the HMAC signature.
 */
export type algorithm = 'sha1' | 'sha256' | 'sha512';

/**
 * AuthSchemeConfigCertificate is a placeholder object with the schemeType set to `certificate`.
 * There is no other config required
 *
 */
export type AuthSchemeConfigCertificate = AuthSchemeConfigBase & {
    schemeType: "certificate";
};

/**
 * AuthSchemeConfig defines how a Connector implements the AuthScheme in order to fulfil its
 * authentication requirements. This is purely the configuration and not the actual credential
 * which is used to authenticate. The credential uses this configuration to determine how to
 * authenticate.
 *
 */
export type AuthSchemeConfig = AuthSchemeConfigNone | AuthSchemeConfigAPIKey | AuthSchemeConfigBasicAuth | AuthSchemeConfigOAuth2 | AuthSchemeConfigHMAC | AuthSchemeConfigCertificate;

/**
 * CredentialType denotes the type of the credential which determines what the Credential's `data` property will
 * contain.
 *
 * - none: No credential is required to authenticate with the Connector.
 * - string: The credential is a string value, such as an API key or password.
 * - binary: The credential is a binary value, such as a private key, certificate or other file.
 * - basic-auth: The credential is a username and password to be used for basic authentication.
 * - oauth2-client: The credential is an OAuth2 client ID and secret to be used for OAuth2 authentication.
 * - oauth2-code: The credential is a temporary authorization code which will be exchanged for an oauth2-token.
 * - oauth2-password: The credential is an OAuth2 username and password with an optional client ID and secret to be used for OAuth2 authentication.
 * - oauth2-token: The credential is an OAuth2 access_token to be used for OAuth2 authentication.
 * - custom-function: The credential is a custom function which will be called to authenticate with the Connector.
 * - jwt-bearer: The credential is the JWT setup values to be used for generating a bearer token.
 * - certificate: The credential is a PEM encoded certificate, key and CA to be used for TLS client authentication.
 *
 */
export type CredentialType = 'none' | 'string' | 'binary' | 'basic-auth' | 'oauth2-client' | 'oauth2-code' | 'oauth2-password' | 'oauth2-token' | 'custom-function' | 'certificate' | 'jwt-bearer';

/**
 * CredentialDataNone contains no data as no credential is required to authenticate with the Connector. It is used
 * purely as a placeholder to implement a consistent interface across all CredentialType/AuthSchemeTypes.
 *
 */
export type CredentialDataNone = {
    [key: string]: unknown;
};

/**
 * CredentialDataString contains a string value and nothing else and is commonly used for API keys. This value
 * will be redacted when returned in a response.
 *
 */
export type CredentialDataString = {
    /**
     * Value is a UTF-8 string containing the credential data. When read from the API this field will be redacted.
     *
     */
    value: string;
};

/**
 * CredentialDataBinary is commonly used to store non-string data such as binary files or encryption keys. This
 * value will be redacted when returned in a response.
 *
 */
export type CredentialDataBinary = {
    /**
     * Value is a base64 encoded string containing the credential data. This could decode to a valid utf-8 string,
     * or it could decode to a binary file such as a private key etc. When read from the API this field will be
     * redacted.
     *
     */
    valueBase64: string;
};

/**
 * CredentialDataBasicAuth contains the username and password required to authenticate with the Connector. The
 * `password` property will be redacted when returned in a response.
 *
 */
export type CredentialDataBasicAuth = {
    /**
     * Username is the username used to authenticate with the Connector.
     */
    username: string;
    /**
     * Password is the password used to authenticate with the Connector. Will be redacted when returned in a
     * response.
     *
     */
    password: string;
};

/**
 * CredentialDataOAuth2Client contains the OAuth2 client credentials required to either issue an access token from
 * a refresh_token, or via the `client_credentials` and `authorization_code` grant types. The `clientSecret` property will be redacted when
 * returned in a response.
 *
 */
export type CredentialDataOAuth2Client = {
    /**
     * ClientID is the OAuth2 client ID used to authenticate with the Connector.
     *
     */
    clientId: string;
    /**
     * ClientSecret is the OAuth2 client secret used to authenticate with the Connector. Will be redacted when
     * returned in a response.
     *
     */
    clientSecret: string;
    /**
     * AuthorizeURL is the URL which the user will be redirected to in order to authorize the application. If
     * the client is being used for a `client_credentials` grant type, this field should be set to an empty
     * string.
     *
     */
    authorizeUrl: string;
    /**
     * TokenURL is the URL which the application will use to issue an access token.
     */
    tokenUrl: string;
    /**
     * Scopes is a list of scopes which should be requested when issuing an access token. This is only required if
     * this credential is being used on a `client_credentials` grant type, for `authorization_code` grant types the
     * requested scopes come from the `CredentialDataOAuth2Token` credential.
     *
     */
    scopes?: Array<(string)>;
    /**
     * AdditionalParams is a URL-encoded query string which can be used to pass additional
     * parameters to the OAuth 2.0 token endpoint. These parameters are attached to the body
     * in the formatted as the `application/x-www-form-urlencoded` content-type.
     *
     */
    additionalParams?: string;
    /**
     * MTLSEnabled is a boolean flag which determines whether the client should use mutual TLS authentication when
     * communicating with the OAuth2 provider. If enabled, the `mTLSCredentialId` field must be set, or it must be
     * created via the `CreateConnection` endpoint with an associated mTLS credential defined beforehand, in which
     * case the mTLSCredentialID field will be populated upon saving by the API.
     *
     */
    mTLSEnabled?: boolean;
    /**
     * MTLSCredentialID is an optional reference to another credential being created.
     * If set the certificate credential will be used when making a request to the tokenUrl.
     *
     */
    mTLSCredentialId?: string;
};

/**
 * CredentialDataOAuth2Code is used to exchange an authorization code for an access token and
 * is denoted by the `oauth2-code` type.
 * This is only used when creating or updating an OAuth 2.0 connection using the
 * `authorization_code` grant type. Retrieving this credential will return a payload of
 * type `oauth2-token` in the shape of a `CredentialDataOAuth2Token` object.
 *
 */
export type CredentialDataOAuth2Code = {
    /**
     * Code is the authorization code which will be exchanged for an access token.
     *
     */
    code: string;
    /**
     * State is the state value which is propagated through the OAuth2 flow.
     *
     */
    state: string;
};

/**
 * CredentialDataOAuth2Token is primarily used to store the refresh_token for an user who has authorized an OAuth2
 * Application to access their data. However, this information is not exposed publicly and the only data visible
 * via the API are the `scopes` which the user has granted consent for. This can be used to determine whether
 * the user should be prompted to re-authorize the application with additional scopes in the event they choose to
 * use a new endpoint which requires additional scopes to what they've already consented to.
 *
 */
export type CredentialDataOAuth2Token = {
    /**
     * Scopes is a list of scopes which the user has granted consent for.
     */
    scopes: Array<(string)>;
    /**
     * AccessToken is the OAuth2 access token which can be used to authenticate with the Connector. This
     * information is redacted when read from the API.
     *
     */
    accessToken?: string;
    /**
     * RefreshToken is the OAuth2 refresh token which can be used to issue new access tokens. This information is
     * redacted when read from the API.
     *
     */
    refreshToken?: string;
};

/**
 * CredentialDataOAuth2Password contains the username and password of a Resource Owner within an OAuth 2.0
 * application. The `password` property will be redacted when returned in a response.
 *
 */
export type CredentialDataOAuth2Password = {
    /**
     * Username is the username used to authenticate with the Connector.
     */
    username: string;
    /**
     * Password is the password used to authenticate with the Connector. Will be redacted when returned in a
     * response.
     *
     */
    password: string;
};

/**
 * CredentialDataCertificate contains the Certificate, Certificate key and CA(Certificate authority).
 *
 */
export type CredentialDataCertificate = {
    /**
     * Certificate is the certificate that will be send to the connection.
     */
    certificate: string;
    /**
     * Key is the accompanying key for the certificate.
     */
    key: string;
    /**
     * CA is the Certificate Authority to verify the server certificates against.
     */
    ca: string;
};

/**
 * CredentialCreateBase contains the common fields to create a new credential.
 */
export type CredentialCreate = {
    /**
     * Name is the name of the Credential.
     */
    name: string;
    type: CredentialType;
    data: (CredentialDataNone | CredentialDataString | CredentialDataBinary | CredentialDataBasicAuth | CredentialDataOAuth2Client | CredentialDataOAuth2Code | CredentialDataOAuth2Token | CredentialDataOAuth2Password | CredentialDataCertificate);
};

/**
 * ConnectionCredentialCreate contains an AuthSchemeConfig and either a Credential to create, or a reference to  an existing Credential to define how the connection should authenticate to a Connector.
 */
export type ConnectionCredentialCreate = {
    authSchemeConfig: AuthSchemeConfig;
    credential: CredentialCreate;
};

/**
 * ConnectionCredentialsCreate defines the Action and Trigger credentials for the owning Connector.
 *
 * This supports defining multiple credentials for each type, which are applied to the request in the order they
 * are defined. This is to enable Connectors which require both a user session token and an API key to be provided
 * in the request.
 *
 * This object can either define a reference to an existing Credential via the InferredReference object, or it can
 * define a new Credential via the CredentialCreate object.
 *
 */
export type ConnectionCredentialsCreate = {
    action?: Array<ConnectionCredentialCreate>;
    trigger?: Array<ConnectionCredentialCreate>;
};

/**
 * ConnectionVariable denotes an arbitrary key/value pair which can be used to configure a connector.
 */
export type ConnectionVariable = {
    /**
     * Name is the name of the connection variable.
     */
    name: string;
    /**
     * Value is the value of the connection variable.
     */
    value: string;
};

/**
 * ConnectionCreate defines the connection to create against a Connector.
 */
export type ConnectionCreate = {
    /**
     * Name is the name of the Connection.
     */
    name: string;
    credentials: ConnectionCredentialsCreate;
    variables: Array<ConnectionVariable>;
};

/**
 * ProtocolType denotes the set of all valid connector types.
 */
export type ProtocolType = 'http' | 'bigquery';

/**
 * ConnectorSummaryBase exposes a summary of a Connector irrespective of protocol.
 */
export type ConnectorSummaryBase = {
    /**
     * ID is the unique identifier of the Connector.
     */
    id: string;
    /**
     * OrganisationID is the unique identifier of the Organisation that owns the Connector.
     */
    organisationId: string;
    /**
     * Name is the user-provided name of the Connector
     */
    name: string;
    protocol: ProtocolType;
    /**
     * CreatedAt is the time at which the ConnectorVersion was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time at which the ConnectorVersion was last updated, including any changes to child
     * resources.
     *
     */
    updatedAt: string;
};

/**
 * CredentialUsageConnection contains the information about an Connection which is using a Credential. This also
 * includes a summary of the Connector it belongs to.
 *
 */
export type CredentialUsageConnection = {
    /**
     * ID is the unique identifier of the Connection. Typically this is only used internally and most (if not all)
     * public-facing APIs will use the `name` in combination with the Connector's `id` instead.
     *
     */
    id: string;
    /**
     * Name is the name of the Connection.
     */
    name: string;
    connector: ConnectorSummaryBase;
    /**
     * CreatedAt is the time the Connection was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time the Connection was last updated.
     */
    updatedAt: string;
};

/**
 * CredentialUsage contains the information about a Connector which is using a Credential. This object currently
 * only supports tracking usage by other connections, but in the future new fields may be added to track usage
 * by other entities such as, but not limited to, Boards, Hubs and Users.
 *
 */
export type CredentialUsage = {
    connection: CredentialUsageConnection;
};

/**
 * CredentialUsages is a list of references to the Connectors which are using this Credential. To aid performance,
 * this field will only be defined for specific endpoints. An undefined property means that the usages have not
 * been loaded, whereas an empty array indicates that the credential is not used by any connectors.
 *
 */
export type CredentialUsages = Array<CredentialUsage>;

/**
 * CredentialBase is the base type for all credentials. It contains the common properties which are shared across
 * all credential types.
 *
 */
export type Credential = {
    /**
     * ID is the unique identifier of the Credential.
     */
    id: string;
    /**
     * OrganisationID is the unique identifier of the Organisation which owns the Credential.
     */
    organisationId: string;
    type: CredentialType;
    /**
     * Name is the name of the Credential.
     */
    name: string;
    usages?: CredentialUsages;
    /**
     * Errors is a list of errors which occurred when attempting to validate the credential. This field may be
     * undefined, which implies that validation has not occurred and the consumer cannot assume whether this
     * Credential is valid or not. An empty array indicates that the Credential is valid.
     *
     */
    errors?: Array<(string)>;
    data: (CredentialDataNone | CredentialDataString | CredentialDataBinary | CredentialDataBasicAuth | CredentialDataOAuth2Client | CredentialDataOAuth2Token | CredentialDataOAuth2Code | CredentialDataOAuth2Password | CredentialDataCertificate);
    /**
     * ExpiresAt denotes the time this credential should be automatically deleted. External systems can subscribe
     * to deletion events and if the reason is "expired", can trigger the correct notifications to interested
     * parties (such as un-publishing jobs which rely on the credential and emailing the owner to rectify it).
     *
     */
    expiresAt?: string;
};

/**
 * ConnectionCredential contains the a Credential and the AuthSchemeConfig to define how the Credential should be used against the Connection's Connector.
 */
export type ConnectionCredential = {
    id: string;
    authSchemeConfig: AuthSchemeConfig;
    credential: Credential;
};

/**
 * ConnectionCredentials defines the Action and Trigger credentials for the owning Connector. If multiple
 * credentials are defined for each type, they are applied to the request in the order they are defined. This is to
 * enable Connectors which require both a user session token and an API key to be provided in the request.
 *
 */
export type ConnectionCredentials = {
    action?: Array<ConnectionCredential>;
    trigger?: Array<ConnectionCredential>;
};

/**
 * Connection defines the Action and Trigger credentials for the owning Connector, and additional variables
 * which can be used to customize the Connector in a particular connection.
 *
 */
export type Connection = {
    /**
     * ID is the unique identifier of the Connection. Typically this is only used internally and most (if not all)
     * public-facing APIs will use the `name` in combination with the Connector's `id` instead.
     *
     */
    id: string;
    /**
     * Name is the name of the Connection. This must be unique within the owning Connector.
     */
    name: string;
    credentials: ConnectionCredentials;
    variables: Array<ConnectionVariable>;
    /**
     * CreatedAt is the time the Connection was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time the Connection was last updated.
     */
    updatedAt: string;
};

/**
 * ConnectionSummary defines a summary of an Connection.
 */
export type ConnectionSummary = {
    /**
     * ID is the unique identifier of the Connection. Typically this is only used internally and most (if not all)
     * public-facing APIs will use the `name` in combination with the Connector's `id` instead.
     *
     */
    id: string;
    /**
     * Name is the name of the Connection.
     */
    name: string;
    /**
     * CreatedAt is the time the Connection was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time the Connection was last updated.
     */
    updatedAt: string;
};

/**
 * InitialiseOAuth2ConnectionRequest is the payload to initialise an OAuth 2.0 connection.
 *
 */
export type InitialiseOAuth2ConnectionRequest = {
    credential: {
        /**
         * ID is the unique identifier of the credential which is being used to
         * initialise the connection. This is used to load the client_secret when the authorisation
         * code is exchanged for an access token.
         *
         */
        id: string;
        /**
         * OrganisationID is the unique identifier of the organisation which the credential is
         * associated with. This is used to ensure that the credential is only used to initialise
         * connections for the organisation which owns the credential.
         *
         */
        organisationId: string;
    };
    /**
     * AuthorizeURL is the URL which the user will be redirected to in order to authorize
     * the application.
     *
     */
    authorizeUrl: string;
    /**
     * ClientID is the OAuth 2.0 client ID which is used to identify the application to the
     * OAuth 2.0 provider.
     *
     */
    clientId: string;
    /**
     * Scopes is a list of OAuth 2.0 scopes which the application is requesting access to.
     *
     * Unless `disableOfflineAccess` is set to true, the API will also include the standard
     * `offline_access` scope in addition to the ones provided here.
     *
     */
    scopes?: Array<(string)>;
    /**
     * DisableOfflineAccess is a flag which can be set to true to disable the inclusion of the
     * standard `offline_access` scope in the list of scopes. This is defined separately to
     * `scopes` to make it clear that the API will always include the `offline_access` scope
     * by default, but can be disabled if the system does not implement the standards so that
     * the user can define their own custom scope as part of `scopes`.
     *
     */
    disableOfflineAccess?: boolean;
    /**
     * Prompt controls the behaviour of the OAuth 2.0 provider when the user is redirected to
     * the authorize URL. This is typically used to force the user to re-authenticate or to
     * select a user account.
     *
     * If set, should be one of "none", "login", "consent", "select_account". However the
     * specification dictates that arbitrary prompts may be provided in case of new values
     * added in the future. Some providers also allow multiple values to be provided, separated
     * by the '+' symbol, i.e. `consent+select_account`.
     *
     * If not provided, this API defaults to "login", unless `additionalParams` contains the
     * `approval_prompt` parameter (thanks, Google refresh tokens), in which case this value
     * does not default to anything.
     *
     */
    prompt?: string;
    /**
     * AdditionalParams is a URL-encoded query string which can be used to pass additional
     * parameters to the OAuth 2.0 authorize endpoint. These cannot conflict with any of the
     * other parameters defined by the request, an attempt to do so will result in an error.
     *
     * These parameters are attached to returned URL as query parameters.
     *
     */
    additionalParams?: string;
};

/**
 * InitialiseOAuth2ConnectionResponse contains the URL to redirect the user to in order to
 * initiate an OAuth 2.0 `authorization_code` grant flow.
 *
 */
export type InitialiseOAuth2ConnectionResponse = {
    /**
     * The URL to redirect the user to.
     */
    url: string;
};

export type Parameterorganisation_id = string;

export type Parameterconnector_id = ULID;

export type Parameterhub_id = ULID;

/**
 * UserID references an End User in the Hub.
 *
 * Most APIs support setting this value to either the internal Versori identifier or their external ID as
 * determined by the organisation. The `identifier_type` query parameter is used to indicate which type of ID is
 * being used.
 *
 */
export type Parameteruser_id = string;

/**
 * ConnectionTemplateID references a Connection Template in the Hub.
 *
 */
export type Parameterconnection_template_id = ULID;

/**
 * IdentifierType indicates whether the `user_id` path parameter is a internal identifier created by Versori, or an
 * external identifier. If the value is `external`, some endpoints also require the `hub` query parameter to
 * identify the correct Hub.
 *
 */
export type Parameteridentifier_type = 'internal' | 'external';

export type Parameterintegration_id = ULID;

export type Parameteractivation_id = ULID;

export type Parameterfirst = number;

export type Parameterbefore = string;

export type Parameterafter = string;

export type Parametersort = string;

export type ListHubsData = {
    path: {
        organisation_id: string;
    };
};

export type ListHubsResponse = (HubsPage);

export type ListHubsError = (Error);

export type CreateHubData = {
    body?: HubCreate;
};

export type CreateHubResponse = (Hub);

export type CreateHubError = (Error);

export type GetHubData = {
    path: {
        hub_id: ULID;
    };
};

export type GetHubResponse = (Hub);

export type GetHubError = (Error);

export type CreateEndUserData = {
    body?: EndUserCreate;
    path: {
        hub_id: ULID;
    };
};

export type CreateEndUserResponse = (EndUser);

export type CreateEndUserError = (Error);

export type ListEndUsersData = {
    path: {
        hub_id: ULID;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
        /**
         * Search is a string that is used to filter the list of End Users. The search string is matched against the
         * id, externalId and displayName fields.
         *
         */
        search?: string;
    };
};

export type ListEndUsersResponse = (EndUserPage);

export type ListEndUsersError = (Error);

export type GetEndUserData = {
    path: {
        hub_id: ULID;
        /**
         * UserID references an End User in the Hub.
         *
         * Most APIs support setting this value to either the internal Versori identifier or their external ID as
         * determined by the organisation. The `identifier_type` query parameter is used to indicate which type of ID is
         * being used.
         *
         */
        user_id: string;
    };
    query?: {
        /**
         * IdentifierType indicates whether the `user_id` path parameter is a internal identifier created by Versori, or an
         * external identifier. If the value is `external`, some endpoints also require the `hub` query parameter to
         * identify the correct Hub.
         *
         */
        identifier_type?: 'internal' | 'external';
    };
};

export type GetEndUserResponse = (EndUser);

export type GetEndUserError = (Error);

export type CreateEndUserConnectionData = {
    body?: {
        connectorId: string;
        connection: ConnectionCreate;
    };
    path: {
        hub_id: ULID;
        /**
         * UserID references an End User in the Hub.
         *
         * Most APIs support setting this value to either the internal Versori identifier or their external ID as
         * determined by the organisation. The `identifier_type` query parameter is used to indicate which type of ID is
         * being used.
         *
         */
        user_id: string;
    };
    query?: {
        /**
         * IdentifierType indicates whether the `user_id` path parameter is a internal identifier created by Versori, or an
         * external identifier. If the value is `external`, some endpoints also require the `hub` query parameter to
         * identify the correct Hub.
         *
         */
        identifier_type?: 'internal' | 'external';
    };
};

export type CreateEndUserConnectionResponse = (Connection);

export type CreateEndUserConnectionError = (Error);

export type ListEndUserConnectionsData = {
    path: {
        hub_id: ULID;
        /**
         * UserID references an End User in the Hub.
         *
         * Most APIs support setting this value to either the internal Versori identifier or their external ID as
         * determined by the organisation. The `identifier_type` query parameter is used to indicate which type of ID is
         * being used.
         *
         */
        user_id: string;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
        /**
         * Search is a string that is used to filter the list of Connections. The search string is matched against the
         * name.
         *
         */
        hub_connector_id?: Array<(string)>;
        /**
         * IdentifierType indicates whether the `user_id` path parameter is a internal identifier created by Versori, or an
         * external identifier. If the value is `external`, some endpoints also require the `hub` query parameter to
         * identify the correct Hub.
         *
         */
        identifier_type?: 'internal' | 'external';
    };
};

export type ListEndUserConnectionsResponse = (EndUserConnectionsPage);

export type ListEndUserConnectionsError = (Error);

export type CreateIntegrationData = {
    body?: IntegrationCreate;
    path: {
        hub_id: ULID;
    };
};

export type CreateIntegrationResponse = (Integration);

export type CreateIntegrationError = (Error);

export type ListIntegrationsData = {
    path: {
        hub_id: ULID;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
        /**
         * Search is a string that is used to filter the list of Integrations. The search string is matched against the
         * name.
         *
         */
        search?: string;
    };
};

export type ListIntegrationsResponse = (ListIntegrations);

export type ListIntegrationsError = (Error);

export type DeleteIntegrationData = {
    path: {
        integration_id: ULID;
    };
};

export type DeleteIntegrationResponse = (void);

export type DeleteIntegrationError = (Error);

export type CreateHubConnectionTemplateData = {
    body?: HubConnectionTemplateCreate;
    path: {
        integration_id: ULID;
    };
};

export type CreateHubConnectionTemplateResponse = (HubConnectionTemplate);

export type CreateHubConnectionTemplateError = (Error);

export type ListIntegrationConnectionTemplatesData = {
    path: {
        integration_id: ULID;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
    };
};

export type ListIntegrationConnectionTemplatesResponse = (HubConnectionTemplatePage);

export type ListIntegrationConnectionTemplatesError = (Error);

export type UpdateIntegrationMetadataData = {
    body?: IntegrationMetadata;
    path: {
        integration_id: ULID;
    };
};

export type UpdateIntegrationMetadataResponse = (void);

export type UpdateIntegrationMetadataError = (Error);

export type GetEndUserConnectionData = {
    path: {
        /**
         * ConnectionTemplateID references a Connection Template in the Hub.
         *
         */
        connection_template_id: ULID;
        /**
         * UserID references an End User in the Hub.
         *
         * Most APIs support setting this value to either the internal Versori identifier or their external ID as
         * determined by the organisation. The `identifier_type` query parameter is used to indicate which type of ID is
         * being used.
         *
         */
        user_id: string;
    };
};

export type GetEndUserConnectionResponse = (Connection);

export type GetEndUserConnectionError = (Error);

export type ListEndUserIntegrationsData = {
    path: {
        hub_id: ULID;
        /**
         * UserID references an End User in the Hub.
         *
         * Most APIs support setting this value to either the internal Versori identifier or their external ID as
         * determined by the organisation. The `identifier_type` query parameter is used to indicate which type of ID is
         * being used.
         *
         */
        user_id: string;
    };
    query?: {
        /**
         * Deployed allowing filtering integrations to only return either deployed (`true`) or not deployed (`false`)
         * integrations.
         *
         * If not set, all integrations are returned.
         *
         */
        deployed?: boolean;
        /**
         * IdentifierType indicates whether the `user_id` path parameter is a internal identifier created by Versori, or an
         * external identifier. If the value is `external`, some endpoints also require the `hub` query parameter to
         * identify the correct Hub.
         *
         */
        identifier_type?: 'internal' | 'external';
    };
};

export type ListEndUserIntegrationsResponse = (EmbeddedIntegrationPage);

export type ListEndUserIntegrationsError = (Error);

export type GetEmbeddedIntegrationData = {
    path: {
        hub_id: ULID;
        integration_id: ULID;
        /**
         * UserID references an End User in the Hub.
         *
         * Most APIs support setting this value to either the internal Versori identifier or their external ID as
         * determined by the organisation. The `identifier_type` query parameter is used to indicate which type of ID is
         * being used.
         *
         */
        user_id: string;
    };
    query?: {
        /**
         * IdentifierType indicates whether the `user_id` path parameter is a internal identifier created by Versori, or an
         * external identifier. If the value is `external`, some endpoints also require the `hub` query parameter to
         * identify the correct Hub.
         *
         */
        identifier_type?: 'internal' | 'external';
    };
};

export type GetEmbeddedIntegrationResponse = (EmbeddedIntegration);

export type GetEmbeddedIntegrationError = (Error);

export type InitialiseOauth2EmbeddedConnectionData = {
    body?: InitialiseOAuth2ConnectionRequest;
    path: {
        connector_id: ULID;
        hub_id: ULID;
    };
};

export type InitialiseOauth2EmbeddedConnectionResponse = (InitialiseOAuth2ConnectionResponse);

export type InitialiseOauth2EmbeddedConnectionError = (Error);

export type ListEndUserActivationsData = {
    path: {
        hub_id: ULID;
        /**
         * UserID references an End User in the Hub.
         *
         * Most APIs support setting this value to either the internal Versori identifier or their external ID as
         * determined by the organisation. The `identifier_type` query parameter is used to indicate which type of ID is
         * being used.
         *
         */
        user_id: string;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
        /**
         * IntegrationID allows returning only activations for a specific integration.
         *
         */
        integration_id?: string;
    };
};

export type ListEndUserActivationsResponse = (ActivationPage);

export type ListEndUserActivationsError = (Error);

export type ActivateIntegrationData = {
    body?: ActivationCreate;
};

export type ActivateIntegrationResponse = (Activation);

export type ActivateIntegrationError = (Error);

export type GetActivationData = {
    path: {
        activation_id: ULID;
    };
};

export type GetActivationResponse = (Activation);

export type GetActivationError = (Error);

export type DeleteActivationData = {
    path: {
        activation_id: ULID;
    };
};

export type DeleteActivationResponse = (void);

export type DeleteActivationError = (Error);

export type HealthCheckResponse = (HealthResponse);

export type HealthCheckError = unknown;