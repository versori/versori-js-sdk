// This file is auto-generated by @hey-api/openapi-ts

/**
 * ErrorField denotes a field which has an error.
 */
export type ErrorField = {
    /**
     * Field is the name of the field which has an error, this may be a path to a nested field, including array
     * elements. The format of this field is of the form: "field1.field2[0].field3"
     *
     */
    field: string;
    /**
     * Message is the error message for this specific field.
     */
    message: string;
};

export type Error = {
    /**
     * Code is a machine-readable error code.
     */
    code: string;
    /**
     * Message is a human-readable error message.
     */
    message: string;
    fields?: Array<ErrorField>;
    details?: string;
};

export type Category =
    | 'Development & IT'
    | 'ERP'
    | 'Supply Chain & Logistics'
    | 'Communication'
    | 'Accounting'
    | 'Hospitality'
    | 'Productivity'
    | 'HR'
    | 'CRM'
    | 'AI/LLMs'
    | 'eCommerce'
    | 'Business Operations';

export type PageInfo = {
    totalCount: number;
    next?: string;
    prev?: string;
};

export type Tags = {
    [key: string]: unknown;
};

/**
 * ProtocolType denotes the set of all valid connector types.
 */
export type ProtocolType = 'http' | 'bigquery';

export type MessageSeverity = 'info' | 'warning' | 'error';

/**
 * Message is a message to be displayed to the user to indicate some information about the
 * preceding request.
 *
 */
export type Message = {
    /**
     * Text contains the text of the message.
     */
    text: string;
    severity: MessageSeverity;
    /**
     * Details contains additional information about the message. This is intended to be used
     * to provide more information about the message, such as a list of validation errors.
     *
     */
    detail?: Array<string>;
};

export type AuthSchemeConfigBase = {
    /**
     * ID is the unique identifier of the AuthSchemeConfig, this is generated by the client and
     * only requires to be unique amongst the elements of the array in which is it contained.
     *
     */
    id: string;
    /**
     * Description enables users to distinguish multiple configurations which use the same
     * schemeType.
     *
     */
    description: string;
    /**
     * ValidationMessages is a list of messages which are generated when the AuthSchemeConfig
     * is validated. This is typically used to provide feedback to the user when they are
     * creating or updating the AuthSchemeConfig.
     *
     * This field will be ignored if sent to the API.
     *
     */
    validationMessages?: Array<Message>;
};

/**
 * AuthSchemeConfigNone is a placeholder object with the schemeType set to `none`. There is no other configuration
 * required.
 *
 */
export type AuthSchemeConfigNone = AuthSchemeConfigBase & {
    schemeType: 'none';
};

/**
 * AuthSchemeConfigAPIKeyIn defines the location of the API key in the request.
 *
 */
export type AuthSchemeConfigAPIKeyIn = 'query' | 'header' | 'cookie';

/**
 * AuthSchemeConfigAPIKey defines how a Connector uses an API key credential to authenticate with the system.
 *
 */
export type AuthSchemeConfigAPIKey = AuthSchemeConfigBase & {
    schemeType: 'api-key';
    /**
     * Name is the query parameter/header/cookie name which will be used to send the API key.
     */
    name: string;
    in: AuthSchemeConfigAPIKeyIn;
};

/**
 * AuthSchemeConfigBasicAuth is a placeholder object with the schemeType set to `basic-auth`. There is no other
 * configuration required.
 *
 */
export type AuthSchemeConfigBasicAuth = AuthSchemeConfigBase & {
    schemeType: 'basic-auth';
};

/**
 * OAuth2Scope represents a single scope which can be requested by an OAuth2 application.
 *
 */
export type OAuth2Scope = {
    /**
     * Name is the name of the scope as determined by the application to which this Connector
     * is connecting to.
     *
     */
    name: string;
    /**
     * Description describes the scope in human-friendly terminology. This text may be
     * displayed to users via a help tooltip or similar.
     *
     */
    description?: string;
};

/**
 * AuthSchemeConfigOAuth2GrantAuthorizationCode contains grant-specific configuration for the
 * `authorization_code` grant type.
 *
 * How the API manages changes to this configuration is as follows:
 *
 * - CredentialID and OrganisationID are not set, a new credential is created containing the
 * sensitive information and the non-sensitive information is updated in the database.
 * - Otherwise, both the credential and the database are updated using JSON Merge Patch, with
 * undefined properties not being updated.
 * - Any other permutation will result in a 400 Bad Request.
 *
 */
export type AuthSchemeConfigOAuth2GrantAuthorizationCode = {
    grantType: 'authorization_code';
    /**
     * CredentialID is the unique identifier of the Credential which contains the client ID and
     * client secret to be used as part of the `password` flow.
     *
     */
    credentialId?: string;
    /**
     * OrganisationID is the unique identifier of the Organisation that owns the Credential.
     * This can be different to the Connector's OrganisationID since some may be imported from
     * Versori's public library.
     *
     */
    organisationId?: string;
    /**
     * ClientID is the OAuth 2.0 client's identifier. This is not a sensitive value and may be
     * presented to the user in plaintext.
     *
     */
    clientId?: string;
    /**
     * ClientSecret is the OAuth 2.0 client's secret. This is a sensitive value and will not be
     * displayed to the user.
     *
     */
    clientSecret?: string;
};

export type AuthSchemeConfigOAuth2GrantClientCredentials = {
    grantType: 'client_credentials';
};

/**
 * AuthSchemeConfigOAuth2GrantPassword contains grant-specific configuration for the `password`
 * grant type.
 *
 * How the API manages changes to this configuration is as follows:
 *
 * - CredentialID and OrganisationID are not set, a new credential is created containing the
 * sensitive information and the non-sensitive information is created/updated in the
 * database.
 * - Otherwise, both the credential and the database are updated using JSON Merge Patch.
 * - Any other permutation will result in a 400 Bad Request.
 *
 */
export type AuthSchemeConfigOAuth2GrantPassword = {
    grantType: 'password';
    /**
     * CredentialID is the unique identifier of the Credential which contains the client ID and
     * client secret to be used as part of the `password` flow.
     *
     */
    credentialId?: string;
    /**
     * OrganisationID is the unique identifier of the Organisation that owns the Credential. This can be different
     * to the Connector's OrganisationID since some may be imported from Versori's public library.
     *
     */
    organisationId?: string;
    /**
     * ClientID is the OAuth 2.0 client's identifier. This is not a sensitive value and may be presented to the
     * user in plaintext.
     *
     */
    clientId?: string;
    /**
     * ClientSecret is the OAuth 2.0 client's secret. This is a sensitive value and will not be displayed to the
     * user. It may be populated when updating the Credential.
     *
     */
    clientSecret?: string;
};

export type AuthSchemeConfigOAuth2Grant =
    | AuthSchemeConfigOAuth2GrantAuthorizationCode
    | AuthSchemeConfigOAuth2GrantClientCredentials
    | AuthSchemeConfigOAuth2GrantPassword;

/**
 * AuthSchemeConfigOAuth2 defines how a Connector uses an OAuth2 credential to authenticate
 * with the system. This is to be used for all OAuth 2.0 flows which require a client ID and
 * client secret as part of the Connector's configuration. Connectors which use the
 * `client_credentials` grant type, where the user provides the Client ID  and Client Secret at
 * the point where they connect, should use the `AuthSchemeConfigOAuth2ClientCredentials` type
 * instead.
 *
 */
export type AuthSchemeConfigOAuth2 = AuthSchemeConfigBase & {
    schemeType: 'oauth2';
    /**
     * AuthorizeURL is the URL which the user will be redirected to in order to authorize
     * the application.
     *
     */
    authorizeUrl: string;
    /**
     * TokenURL is the URL which the application will use to issue an access token.
     *
     */
    tokenUrl: string;
    /**
     * Scopes is the list of all OAuth2 scopes which the application supports. The user
     * will be allowed to choose which scopes to request when configuring the Connection.
     *
     */
    scopes: Array<OAuth2Scope>;
    /**
     * DefaultScopes is the list of scopes which will be requested by default when the user
     * connects the Connector. This is useful for Connectors which require a specific set
     * of scopes to function correctly.
     *
     */
    defaultScopes: Array<string>;
    /**
     * AdditionalAuthorizeParams is a URL-encoded query string which should be attached to
     * the AuthorizeURL when the user is redirected to the OAuth 2.0 authorization
     * endpoint.
     *
     * This value is only used by the UI to drive the default values when connecting, the
     * API to `InitialiseOAuth2Connection` can be provided a different value if required.
     *
     */
    additionalAuthorizeParams?: string;
    /**
     * AdditionalTokenParams is a URL-encoded string following the
     * `application/x-www-form-urlencoded` mime-type, which can be used to pass additional
     * parameters to the OAuth 2.0 token endpoint within the request body.
     *
     */
    additionalTokenParams?: string;
    /**
     * MTLSEnabled is a flag which determines whether the Connector should use Mutual TLS
     * (mTLS) to authenticate with the OAuth 2.0 token endpoint. This is useful for
     * Connectors which require a higher level of security.
     *
     */
    mtlsEnabled?: boolean;
    /**
     * MTLSCredentialID is the unique identifier of the Credential which contains the
     * client certificate and private key to be used as part of the mTLS connection.
     *
     * This may be unset when creating a connection, in which case if `mtlsEnabled` is
     * true, then the API will find an associated AuthSchemeConfigCertificate and link
     * them automatically.
     *
     */
    mtlsCredentialId?: string;
    grant: AuthSchemeConfigOAuth2Grant;
};

/**
 * AuthSchemeConfigHMACIn defines where the signature should be set on requests.
 */
export type AuthSchemeConfigHMACIn = 'query' | 'header' | 'cookie';

/**
 * AuthSchemeConfigHMAC defines how a Connector uses an HMAC credential to authenticate with the system.
 *
 * This may be used on outbound requests to sign the request body, however it is more commonly used on inbound
 * requests (i.e. from Webhook Triggers) to verify the sender of the request is allowed to invoke the Trigger.
 *
 */
export type AuthSchemeConfigHMAC = AuthSchemeConfigBase & {
    schemeType: 'hmac';
    /**
     * Name is the query parameter/header/cookie name which will be used to send the signature.
     */
    name: string;
    in: AuthSchemeConfigHMACIn;
    /**
     * AuthSchemeConfigHMACAlgorithm defines the hashing algorithm to use when generating the HMAC signature.
     */
    algorithm: 'sha1' | 'sha256' | 'sha512';
    /**
     * AuthSchemeConfigHMACInputs defines what parts of a HTTP request are consumed to generate the HMAC signature. Some systems
     * only generate the signature from the request body, others may include the URL. The order of this array
     * defines the order in which the input is fed into the hashing function.
     *
     */
    digestInputs: Array<'body' | 'url'>;
};

/**
 * AuthSchemeConfigHMACAlgorithm defines the hashing algorithm to use when generating the HMAC signature.
 */
export type algorithm = 'sha1' | 'sha256' | 'sha512';

/**
 * AuthSchemeConfigCertificate is a placeholder object with the schemeType set to `certificate`.
 * There is no other config required
 *
 */
export type AuthSchemeConfigCertificate = AuthSchemeConfigBase & {
    schemeType: 'certificate';
};

/**
 * AuthSchemeConfig defines how a Connector implements the AuthScheme in order to fulfil its
 * authentication requirements. This is purely the configuration and not the actual credential
 * which is used to authenticate. The credential uses this configuration to determine how to
 * authenticate.
 *
 */
export type AuthSchemeConfig =
    | AuthSchemeConfigNone
    | AuthSchemeConfigAPIKey
    | AuthSchemeConfigBasicAuth
    | AuthSchemeConfigOAuth2
    | AuthSchemeConfigHMAC
    | AuthSchemeConfigCertificate;

/**
 * ConnectionVariable denotes an arbitrary key/value pair which can be used to configure a connector.
 */
export type ConnectionVariable = {
    /**
     * Name is the name of the connection variable.
     */
    name: string;
    /**
     * Value is the value of the connection variable.
     */
    value: string;
};

/**
 * CredentialType denotes the type of the credential which determines what the Credential's `data` property will
 * contain.
 *
 * - none: No credential is required to authenticate with the Connector.
 * - string: The credential is a string value, such as an API key or password.
 * - binary: The credential is a binary value, such as a private key, certificate or other file.
 * - basic-auth: The credential is a username and password to be used for basic authentication.
 * - oauth2-client: The credential is an OAuth2 client ID and secret to be used for OAuth2 authentication.
 * - oauth2-code: The credential is a temporary authorization code which will be exchanged for an oauth2-token.
 * - oauth2-password: The credential is an OAuth2 username and password with an optional client ID and secret to be used for OAuth2 authentication.
 * - oauth2-token: The credential is an OAuth2 access_token to be used for OAuth2 authentication.
 * - custom-function: The credential is a custom function which will be called to authenticate with the Connector.
 * - jwt-bearer: The credential is the JWT setup values to be used for generating a bearer token.
 * - certificate: The credential is a PEM encoded certificate, key and CA to be used for TLS client authentication.
 *
 */
export type CredentialType =
    | 'none'
    | 'string'
    | 'binary'
    | 'basic-auth'
    | 'oauth2-client'
    | 'oauth2-code'
    | 'oauth2-password'
    | 'oauth2-token'
    | 'custom-function'
    | 'certificate'
    | 'jwt-bearer';

/**
 * ConnectorSummaryBase exposes a summary of a Connector irrespective of protocol.
 */
export type ConnectorSummaryBase = {
    /**
     * ID is the unique identifier of the Connector.
     */
    id: string;
    /**
     * OrganisationID is the unique identifier of the Organisation that owns the Connector.
     */
    organisationId: string;
    /**
     * Name is the user-provided name of the Connector
     */
    name: string;
    protocol: ProtocolType;
    /**
     * CreatedAt is the time at which the ConnectorVersion was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time at which the ConnectorVersion was last updated, including any changes to child
     * resources.
     *
     */
    updatedAt: string;
};

/**
 * CredentialUsageConnection contains the information about an Connection which is using a Credential. This also
 * includes a summary of the Connector it belongs to.
 *
 */
export type CredentialUsageConnection = {
    /**
     * ID is the unique identifier of the Connection. Typically this is only used internally and most (if not all)
     * public-facing APIs will use the `name` in combination with the Connector's `id` instead.
     *
     */
    id: string;
    /**
     * Name is the name of the Connection.
     */
    name: string;
    connector: ConnectorSummaryBase;
    /**
     * CreatedAt is the time the Connection was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time the Connection was last updated.
     */
    updatedAt: string;
};

/**
 * CredentialUsage contains the information about a Connector which is using a Credential. This object currently
 * only supports tracking usage by other connections, but in the future new fields may be added to track usage
 * by other entities such as, but not limited to, Boards, Hubs and Users.
 *
 */
export type CredentialUsage = {
    connection: CredentialUsageConnection;
};

/**
 * CredentialUsages is a list of references to the Connectors which are using this Credential. To aid performance,
 * this field will only be defined for specific endpoints. An undefined property means that the usages have not
 * been loaded, whereas an empty array indicates that the credential is not used by any connectors.
 *
 */
export type CredentialUsages = Array<CredentialUsage>;

/**
 * CredentialDataNone contains no data as no credential is required to authenticate with the Connector. It is used
 * purely as a placeholder to implement a consistent interface across all CredentialType/AuthSchemeTypes.
 *
 */
export type CredentialDataNone = {
    [key: string]: unknown;
};

/**
 * CredentialDataString contains a string value and nothing else and is commonly used for API keys. This value
 * will be redacted when returned in a response.
 *
 */
export type CredentialDataString = {
    /**
     * Value is a UTF-8 string containing the credential data. When read from the API this field will be redacted.
     *
     */
    value: string;
};

/**
 * CredentialDataBinary is commonly used to store non-string data such as binary files or encryption keys. This
 * value will be redacted when returned in a response.
 *
 */
export type CredentialDataBinary = {
    /**
     * Value is a base64 encoded string containing the credential data. This could decode to a valid utf-8 string,
     * or it could decode to a binary file such as a private key etc. When read from the API this field will be
     * redacted.
     *
     */
    valueBase64: string;
};

/**
 * CredentialDataBasicAuth contains the username and password required to authenticate with the Connector. The
 * `password` property will be redacted when returned in a response.
 *
 */
export type CredentialDataBasicAuth = {
    /**
     * Username is the username used to authenticate with the Connector.
     */
    username: string;
    /**
     * Password is the password used to authenticate with the Connector. Will be redacted when returned in a
     * response.
     *
     */
    password: string;
};

/**
 * CredentialDataOAuth2Client contains the OAuth2 client credentials required to either issue an access token from
 * a refresh_token, or via the `client_credentials` and `authorization_code` grant types. The `clientSecret` property will be redacted when
 * returned in a response.
 *
 */
export type CredentialDataOAuth2Client = {
    /**
     * ClientID is the OAuth2 client ID used to authenticate with the Connector.
     *
     */
    clientId: string;
    /**
     * ClientSecret is the OAuth2 client secret used to authenticate with the Connector. Will be redacted when
     * returned in a response.
     *
     */
    clientSecret: string;
    /**
     * AuthorizeURL is the URL which the user will be redirected to in order to authorize the application. If
     * the client is being used for a `client_credentials` grant type, this field should be set to an empty
     * string.
     *
     */
    authorizeUrl: string;
    /**
     * TokenURL is the URL which the application will use to issue an access token.
     */
    tokenUrl: string;
    /**
     * Scopes is a list of scopes which should be requested when issuing an access token. This is only required if
     * this credential is being used on a `client_credentials` grant type, for `authorization_code` grant types the
     * requested scopes come from the `CredentialDataOAuth2Token` credential.
     *
     */
    scopes?: Array<string>;
    /**
     * AdditionalParams is a URL-encoded query string which can be used to pass additional
     * parameters to the OAuth 2.0 token endpoint. These parameters are attached to the body
     * in the formatted as the `application/x-www-form-urlencoded` content-type.
     *
     */
    additionalParams?: string;
    /**
     * MTLSEnabled is a boolean flag which determines whether the client should use mutual TLS authentication when
     * communicating with the OAuth2 provider. If enabled, the `mTLSCredentialId` field must be set, or it must be
     * created via the `CreateConnection` endpoint with an associated mTLS credential defined beforehand, in which
     * case the mTLSCredentialID field will be populated upon saving by the API.
     *
     */
    mTLSEnabled?: boolean;
    /**
     * MTLSCredentialID is an optional reference to another credential being created.
     * If set the certificate credential will be used when making a request to the tokenUrl.
     *
     */
    mTLSCredentialId?: string;
};

/**
 * CredentialDataOAuth2Token is primarily used to store the refresh_token for an user who has authorized an OAuth2
 * Application to access their data. However, this information is not exposed publicly and the only data visible
 * via the API are the `scopes` which the user has granted consent for. This can be used to determine whether
 * the user should be prompted to re-authorize the application with additional scopes in the event they choose to
 * use a new endpoint which requires additional scopes to what they've already consented to.
 *
 */
export type CredentialDataOAuth2Token = {
    /**
     * Scopes is a list of scopes which the user has granted consent for.
     */
    scopes: Array<string>;
    /**
     * AccessToken is the OAuth2 access token which can be used to authenticate with the Connector. This
     * information is redacted when read from the API.
     *
     */
    accessToken?: string;
    /**
     * RefreshToken is the OAuth2 refresh token which can be used to issue new access tokens. This information is
     * redacted when read from the API.
     *
     */
    refreshToken?: string;
};

/**
 * CredentialDataOAuth2Code is used to exchange an authorization code for an access token and
 * is denoted by the `oauth2-code` type.
 * This is only used when creating or updating an OAuth 2.0 connection using the
 * `authorization_code` grant type. Retrieving this credential will return a payload of
 * type `oauth2-token` in the shape of a `CredentialDataOAuth2Token` object.
 *
 */
export type CredentialDataOAuth2Code = {
    /**
     * Code is the authorization code which will be exchanged for an access token.
     *
     */
    code: string;
    /**
     * State is the state value which is propagated through the OAuth2 flow.
     *
     */
    state: string;
};

/**
 * CredentialDataOAuth2Password contains the username and password of a Resource Owner within an OAuth 2.0
 * application. The `password` property will be redacted when returned in a response.
 *
 */
export type CredentialDataOAuth2Password = {
    /**
     * Username is the username used to authenticate with the Connector.
     */
    username: string;
    /**
     * Password is the password used to authenticate with the Connector. Will be redacted when returned in a
     * response.
     *
     */
    password: string;
};

/**
 * CredentialDataCertificate contains the Certificate, Certificate key and CA(Certificate authority).
 *
 */
export type CredentialDataCertificate = {
    /**
     * Certificate is the certificate that will be send to the connection.
     */
    certificate: string;
    /**
     * Key is the accompanying key for the certificate.
     */
    key: string;
    /**
     * CA is the Certificate Authority to verify the server certificates against.
     */
    ca: string;
};

/**
 * CredentialBase is the base type for all credentials. It contains the common properties which are shared across
 * all credential types.
 *
 */
export type Credential = {
    /**
     * ID is the unique identifier of the Credential.
     */
    id: string;
    /**
     * OrganisationID is the unique identifier of the Organisation which owns the Credential.
     */
    organisationId: string;
    type: CredentialType;
    /**
     * Name is the name of the Credential.
     */
    name: string;
    usages?: CredentialUsages;
    /**
     * Errors is a list of errors which occurred when attempting to validate the credential. This field may be
     * undefined, which implies that validation has not occurred and the consumer cannot assume whether this
     * Credential is valid or not. An empty array indicates that the Credential is valid.
     *
     */
    errors?: Array<string>;
    data:
        | CredentialDataNone
        | CredentialDataString
        | CredentialDataBinary
        | CredentialDataBasicAuth
        | CredentialDataOAuth2Client
        | CredentialDataOAuth2Token
        | CredentialDataOAuth2Code
        | CredentialDataOAuth2Password
        | CredentialDataCertificate;
    /**
     * ExpiresAt denotes the time this credential should be automatically deleted. External systems can subscribe
     * to deletion events and if the reason is "expired", can trigger the correct notifications to interested
     * parties (such as un-publishing jobs which rely on the credential and emailing the owner to rectify it).
     *
     */
    expiresAt?: string;
};

/**
 * ConnectionCredential contains the a Credential and the AuthSchemeConfig to define how the Credential should be used against the Connection's Connector.
 */
export type ConnectionCredential = {
    id: string;
    authSchemeConfig: AuthSchemeConfig;
    credential: Credential;
};

/**
 * ConnectionCredentials defines the Action and Trigger credentials for the owning Connector. If multiple
 * credentials are defined for each type, they are applied to the request in the order they are defined. This is to
 * enable Connectors which require both a user session token and an API key to be provided in the request.
 *
 */
export type ConnectionCredentials = {
    action?: Array<ConnectionCredential>;
    trigger?: Array<ConnectionCredential>;
};

/**
 * Connection defines the Action and Trigger credentials for the owning Connector, and additional variables
 * which can be used to customize the Connector in a particular connection.
 *
 */
export type Connection = {
    /**
     * ID is the unique identifier of the Connection. Typically this is only used internally and most (if not all)
     * public-facing APIs will use the `name` in combination with the Connector's `id` instead.
     *
     */
    id: string;
    /**
     * Name is the name of the Connection. This must be unique within the owning Connector.
     */
    name: string;
    credentials: ConnectionCredentials;
    variables: Array<ConnectionVariable>;
    /**
     * CreatedAt is the time the Connection was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time the Connection was last updated.
     */
    updatedAt: string;
};

/**
 * ConnectorVersion represents a version of a Connector.
 */
export type ConnectorVersion = {
    /**
     * ID is the unique identifier of the ConnectorVersion, this is typically only used internally and the version
     * `name` is used externally in combination with the Connector `id`.
     *
     */
    id: string;
    /**
     * Name denotes the actual version value for the Connector. This can be any value but a consistent naming
     * strategy is recommended, such as SemVer, CalVer or an incrementing number. The names "default" and "latest"
     * are reserved words and cannot be used.
     *
     */
    name: string;
    /**
     * Description allows specifying additional information about the ConnectorVersion, such as what changed
     * since the last version etc.
     *
     */
    description?: string;
    /**
     * IsLatest denotes whether this is the latest version of the Connector.
     */
    isLatest: boolean;
    /**
     * IsDefault denotes whether this is the default version of the Connector.
     */
    isDefault: boolean;
    /**
     * CreatedAt is the time at which the ConnectorVersion was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time at which the ConnectorVersion was last updated, including any changes to child
     * resources.
     *
     */
    updatedAt: string;
    /**
     * PublishedAt is the time at which the ConnectorVersion was published.
     *
     */
    publishedAt: string | null;
    messages?: Array<Message>;
};

/**
 * ConnectorBase holds common fields which exist across all Connector protocols.
 */
export type ConnectorBase = {
    /**
     * ID is the unique identifier of the Connector.
     */
    id: string;
    /**
     * OrganisationID is the unique identifier of the Organisation that owns the Connector.
     */
    organisationId: string;
    /**
     * Name is the user-provided name of the Connector
     */
    name: string;
    public: boolean;
    /**
     * Hold an optional link to the documentation for the API.
     */
    documentationURL?: string;
    /**
     * The URL for the icon for the connector
     */
    imageURL?: string;
    tags?: Tags;
    protocol: ProtocolType;
    authSchemeConfigs: Array<AuthSchemeConfig>;
    /**
     * Connection Variables is a list of default variables initialised in every connector connection.
     */
    connectionVariables?: Array<ConnectionVariable>;
    /**
     * Connections is a list of all the connections this Connector has.
     */
    connections: Array<Connection>;
    /**
     * Versions is a list of all the versions this Connector has.
     */
    versions: Array<ConnectorVersion>;
    /**
     * CreatedAt is the time at which the ConnectorVersion was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time at which the ConnectorVersion was last updated, including any changes to child
     * resources.
     *
     */
    updatedAt: string;
};

/**
 * HTTPConnector represents a connector to an external system over HTTP.
 */
export type HTTPConnector = ConnectorBase & {
    protocol: 'http';
    /**
     * BaseURL is the base URL of all HTTP Actions within the Connector.
     */
    baseUrl: string;
    public: boolean;
};

/**
 * BigQueryConnector represents a connector to a Google BigQuery dataset.
 */
export type BigQueryConnector = ConnectorBase & {
    protocol: 'bigquery';
    /**
     * DatasetID is the ID of the BigQuery dataset, in the format "<project_id>.<dataset_name>"
     */
    datasetId: string;
};

/**
 * Connector represents a connector to an external system.
 */
export type Connector = HTTPConnector | BigQueryConnector;

/**
 * ConnectorPage is a page of Connectors.
 */
export type ConnectorPage = PageInfo & {
    connectors: Array<Connector>;
};

/**
 * ConnectorUpdateBase provides the common fields to update any Connector type. Attempts to mutate a field marked
 *
 * Versions cannot be updated via this endpoint.
 *
 */
export type ConnectorUpdateBase = {
    /**
     * ID is the unique identifier of the Connector.
     */
    id: string;
    /**
     * OrganisationID is the unique identifier of the Organisation that owns the Connector.
     */
    organisationId: string;
    /**
     * Name is the user-provided name of the Connector
     */
    name: string;
    tags?: Tags;
    protocol: ProtocolType;
    /**
     * AuthSchemeConfigIDs allows reordering the AuthSchemeConfigs for the Connector. This field cannot be used to
     * create/edit/delete individual AuthSchemeConfigs, for those use cases, see the API endpoints at
     * `/o/:organisationId/connectors/:connectorId/auth-scheme-configs[/:id]`. If this field is omitted then the
     * AuthSchemeConfigs are not edited.
     *
     */
    authSchemeConfigIds?: Array<string>;
    public?: boolean;
    /**
     * Hold an optional link to the documentation for the API.
     */
    documentationURL?: string;
    /**
     * The URL for the icon for the connector
     */
    imageURL?: string;
};

/**
 * HTTPConnectorUpdate is the input to the UpdateHTTPConnector endpoint. Connections cannot be updated via the
 * UpdateHTTPConnector endpoint. To update an Connection, use the `UpdateConnection` endpoint.
 *
 */
export type HTTPConnectorUpdate = ConnectorUpdateBase & {
    protocol: 'http';
    /**
     * BaseURL is the base URL of all HTTP Actions within the Connector.
     */
    baseUrl: string;
    /**
     * ConnectionVariables, if set, will overwrite the existing list of connection variables or create new ones with the
     * provided array. This action will be performed on all the connector connections as well.
     *
     */
    connectionVariables?: Array<ConnectionVariable>;
};

/**
 * BigQueryConnectorUpdate is the input to the UpdateBigQueryConnector endpoint. Connections cannot be updated
 * via the UpdateBigQueryConnector endpoint. To update an Connection, use the `UpdateConnection` endpoint.
 *
 */
export type BigQueryConnectorUpdate = ConnectorUpdateBase & {
    protocol: 'bigquery';
    /**
     * DatasetID is the ID of the BigQuery dataset, in the format "<project_id>.<dataset_name>"
     */
    datasetId: string;
};

export type protocol = 'bigquery';

/**
 * ConnectorUpdate is the input to the UpdateConnector endpoint.
 */
export type ConnectorUpdate = HTTPConnectorUpdate | BigQueryConnectorUpdate;

/**
 * InitialiseOAuth2ConnectionRequest is the payload to initialise an OAuth 2.0 connection.
 *
 */
export type InitialiseOAuth2ConnectionRequest = {
    credential: {
        /**
         * ID is the unique identifier of the credential which is being used to
         * initialise the connection. This is used to load the client_secret when the authorisation
         * code is exchanged for an access token.
         *
         */
        id: string;
        /**
         * OrganisationID is the unique identifier of the organisation which the credential is
         * associated with. This is used to ensure that the credential is only used to initialise
         * connections for the organisation which owns the credential.
         *
         */
        organisationId: string;
    };
    /**
     * AuthorizeURL is the URL which the user will be redirected to in order to authorize
     * the application.
     *
     */
    authorizeUrl: string;
    /**
     * ClientID is the OAuth 2.0 client ID which is used to identify the application to the
     * OAuth 2.0 provider.
     *
     */
    clientId: string;
    /**
     * Scopes is a list of OAuth 2.0 scopes which the application is requesting access to.
     *
     * Unless `disableOfflineAccess` is set to true, the API will also include the standard
     * `offline_access` scope in addition to the ones provided here.
     *
     */
    scopes?: Array<string>;
    /**
     * DisableOfflineAccess is a flag which can be set to true to disable the inclusion of the
     * standard `offline_access` scope in the list of scopes. This is defined separately to
     * `scopes` to make it clear that the API will always include the `offline_access` scope
     * by default, but can be disabled if the system does not implement the standards so that
     * the user can define their own custom scope as part of `scopes`.
     *
     */
    disableOfflineAccess?: boolean;
    /**
     * Prompt controls the behaviour of the OAuth 2.0 provider when the user is redirected to
     * the authorize URL. This is typically used to force the user to re-authenticate or to
     * select a user account.
     *
     * If set, should be one of "none", "login", "consent", "select_account". However the
     * specification dictates that arbitrary prompts may be provided in case of new values
     * added in the future. Some providers also allow multiple values to be provided, separated
     * by the '+' symbol, i.e. `consent+select_account`.
     *
     * If not provided, this API defaults to "login", unless `additionalParams` contains the
     * `approval_prompt` parameter (thanks, Google refresh tokens), in which case this value
     * does not default to anything.
     *
     */
    prompt?: string;
    /**
     * AdditionalParams is a URL-encoded query string which can be used to pass additional
     * parameters to the OAuth 2.0 authorize endpoint. These cannot conflict with any of the
     * other parameters defined by the request, an attempt to do so will result in an error.
     *
     * These parameters are attached to returned URL as query parameters.
     *
     */
    additionalParams?: string;
};

/**
 * InitialiseOAuth2ConnectionResponse contains the URL to redirect the user to in order to
 * initiate an OAuth 2.0 `authorization_code` grant flow.
 *
 */
export type InitialiseOAuth2ConnectionResponse = {
    /**
     * The URL to redirect the user to.
     */
    url: string;
};

/**
 * ConnectionSummary defines a summary of an Connection.
 */
export type ConnectionSummary = {
    /**
     * ID is the unique identifier of the Connection. Typically this is only used internally and most (if not all)
     * public-facing APIs will use the `name` in combination with the Connector's `id` instead.
     *
     */
    id: string;
    /**
     * Name is the name of the Connection.
     */
    name: string;
    /**
     * CreatedAt is the time the Connection was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time the Connection was last updated.
     */
    updatedAt: string;
};

/**
 * ConnectorConnectionPage defines a page of Connection summaries.
 */
export type ConnectorConnectionPage = PageInfo & {
    items?: Array<ConnectionSummary>;
};

/**
 * CredentialCreateBase contains the common fields to create a new credential.
 */
export type CredentialCreate = {
    /**
     * Name is the name of the Credential.
     */
    name: string;
    type: CredentialType;
    data:
        | CredentialDataNone
        | CredentialDataString
        | CredentialDataBinary
        | CredentialDataBasicAuth
        | CredentialDataOAuth2Client
        | CredentialDataOAuth2Code
        | CredentialDataOAuth2Token
        | CredentialDataOAuth2Password
        | CredentialDataCertificate;
};

/**
 * ConnectionCredentialCreate contains an AuthSchemeConfig and either a Credential to create, or a reference to  an existing Credential to define how the connection should authenticate to a Connector.
 */
export type ConnectionCredentialCreate = {
    authSchemeConfig: AuthSchemeConfig;
    credential: CredentialCreate;
};

/**
 * ConnectionCredentialsCreate defines the Action and Trigger credentials for the owning Connector.
 *
 * This supports defining multiple credentials for each type, which are applied to the request in the order they
 * are defined. This is to enable Connectors which require both a user session token and an API key to be provided
 * in the request.
 *
 * This object can either define a reference to an existing Credential via the InferredReference object, or it can
 * define a new Credential via the CredentialCreate object.
 *
 */
export type ConnectionCredentialsCreate = {
    action?: Array<ConnectionCredentialCreate>;
    trigger?: Array<ConnectionCredentialCreate>;
};

/**
 * ConnectionCreate defines the connection to create against a Connector.
 */
export type ConnectionCreate = {
    /**
     * Name is the name of the Connection.
     */
    name: string;
    credentials: ConnectionCredentialsCreate;
    variables: Array<ConnectionVariable>;
};

/**
 * ConnectionCredentialUpdate allows users to update an AuthSchemeConfig for a given ConnectionCredential. This cannot be used to update the Credential itself, in order to do that the `UpdateCredential` operation should be used.
 * The `authSchemeConfig.schemeType` field cannot be mutated, in order to achieve this a new ConnectionCredential  must be added and the old one deleted.
 */
export type ConnectionCredentialUpdate = {
    id: string;
    authSchemeConfig: AuthSchemeConfig;
};

/**
 * ConnectionCredentialsUpdate defines the Action and Trigger credentials for the owning Connector.
 *
 * Only the order and the AuthSchemeConfig of each ConnectionCredential can be updated. To update the underlying
 * Credential, the `UpdateCredential` operation should be used.
 *
 */
export type ConnectionCredentialsUpdate = {
    action?: Array<ConnectionCredentialUpdate>;
    trigger?: Array<ConnectionCredentialUpdate>;
};

/**
 * ConnectionUpdate defines the updates to apply to an existing Connection.
 *
 * This supports renaming the Connection, editing variables, and updating the order and AuthSchemeConfig of each
 * ConnectionCredential.
 *
 */
export type ConnectionUpdate = {
    /**
     * ID is the unique identifier of the Connection. Typically this is only used internally and most (if not all)
     * public-facing APIs will use the `name` in combination with the Connector's `id` instead.
     *
     */
    id: string;
    /**
     * Name is the new name of the Connection.
     */
    name: string;
    credentials?: ConnectionCredentialsUpdate;
    /**
     * Variables, if set, will replace the existing variables in the Connection. Setting to an empty array will
     * delete all variables. Omitting this field will leave the existing variables unchanged.
     *
     */
    variables?: Array<ConnectionVariable>;
};

/**
 * ConnectorVersionsPage is a page of ConnectorVersions.
 */
export type ConnectorVersionsPage = PageInfo & {
    items: Array<ConnectorVersion>;
};

/**
 * ConnectorVersionCreate is the request body for creating a new ConnectorVersion.
 */
export type ConnectorVersionCreate = {
    /**
     * Name denotes the actual version value for the Connector. This can be any value but a consistent naming
     * strategy is recommended, such as SemVer, CalVer or an incrementing number. The names "default" and "latest"
     * are reserved words and cannot be used.
     *
     */
    name: string;
    /**
     * FromVersion is the `name` of another ConnectorVersion from which this ConnectorVersion should be created.
     * If this is not provided then the ConnectorVersion will be created from scratch with no child resources
     * (i.e. Actions, Definitions etc.).
     *
     */
    fromVersion?: string;
};

/**
 * PublishConnectorResponse contains the published version with updated values after the published occurred. For
 * example, the publishedAt, isLatest and isDraft will be updated to reflect their latest state.
 *
 */
export type PublishConnectorResponse = {
    version: ConnectorVersion;
};

/**
 * UnpublishConnectorResponse contains the unpublished version with updated values after the unpublished
 * occurred. For example, the publishedAt, isLatest and isDraft will be updated to reflect their latest state.
 *
 */
export type UnpublishConnectorResponse = {
    version: ConnectorVersion;
};

/**
 * ActionError is the payload returned when an Action fails validation
 */
export type ActionError = {
    /**
     * Field is the field which failed validation. This is typically a JSON Pointer, i.e.
     * "/parameters/0/properties/id", however this is open for discussion (we should be consistent with the
     * ErrorField type).
     *
     */
    field: string;
    /**
     * Message is a human-readable description of the error. This is typically a human-readable string, i.e.
     * "The parameter 'id' is invalid".
     *
     */
    message: string;
    /**
     * Severity is the severity of the error. This is used to determine how the error should be displayed to the
     * user, i.e. a warning may be displayed in a modal dialog, whereas an error may be displayed inline.
     *
     */
    severity: 'error' | 'warning';
};

/**
 * Severity is the severity of the error. This is used to determine how the error should be displayed to the
 * user, i.e. a warning may be displayed in a modal dialog, whereas an error may be displayed inline.
 *
 */
export type severity = 'error' | 'warning';

export type ActionTypeEnum = 'http';

/**
 * ActionCommon defines all the common fields for an Action.
 */
export type ActionCommon = {
    type: ActionTypeEnum;
    /**
     * Name is a unique identifier for the Action within the scope of the Connector. It is expected to both
     * human and machine-readable, i.e. "GetProduct" or "get_products", see the validation regex for more details.
     *
     */
    name: string;
    /**
     * Summary is a human-readable version of the `id` field, i.e. "Get Product" or "Get Products". This is used
     * when displaying the Action to users, however if omitted the `actionId` can be used to display to users
     * instead.
     *
     */
    summary?: string;
    /**
     * Description is a human-readable description of the Action. It can provide extra information to users about how
     * the Action operates and anything the user may need to be aware of when using it.
     *
     */
    description?: string;
};

/**
 * ActionBase defines all the common fields for an Action.
 *
 */
export type ActionBase = {
    /**
     * ID is the unique identifier of the Action.
     */
    id: string;
    /**
     * Errors is a list of ErrorField objects which defines the errors which may be returned by the Action. An
     * empty array denotes that the Action has been validated and no errors were found. If this field is
     * undefined then this means validation has not occurred.
     *
     */
    errors?: Array<ActionError>;
} & ActionCommon;

/**
 * HTTPMethod defines the HTTP method which will be used when invoking the Action. This is typically one of the
 * standard HTTP methods such as GET, POST, PUT, PATCH or DELETE, but may be any valid HTTP method.
 *
 */
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'CONNECT' | 'TRACE';

/**
 * ActionPath is appended to the Connector's base URL to build the full URL to send requests to. It may
 * also contain placeholders to inject dynamic values from the following sources:
 *
 * - `{{ param.<name> }}` - Injects the value of the parameter with the given name.
 * - `{{ conn.<name> }}` - Injects the value of the connection variable with the given name.
 *
 */
export type ActionPath = string;

export type ActionHTTPParameterIn = 'cookie' | 'header' | 'path' | 'query';

/**
 * ActionCompletion defines how an Action may be completed by Switchboard to aid the user in selecting a valid
 * value. Schema TBD.
 *
 */
export type ActionCompletion = {
    [key: string]: unknown;
};

/**
 * ActionHTTPParameter defines a parameter which is sent to the HTTP endpoint when invoking the Action. This may
 * be a query parameter, header or cookie depending on the `in` field.
 *
 */
export type ActionHTTPParameter = {
    /**
     * Name is the name of the parameter which will be sent to the HTTP endpoint.
     */
    name: string;
    in: ActionHTTPParameterIn;
    /**
     * Required denotes whether this parameter is required.
     */
    required: boolean;
    /**
     * Type is the type of the parameter. Currently only scalar types are supported, if you
     * require complex types then get in touch with support to discuss options.
     *
     */
    type: 'string' | 'number' | 'integer' | 'boolean';
    /**
     * Default is the default value to use for the parameter if no value is provided by the
     * user. If this is not defined then the parameter will not be sent to the HTTP endpoint
     * if no value is explicitly provided by the user.
     *
     * If this value is a string, it may be templated using a Go-formatted template
     * string, i.e. `{{ .conn.foo }}` where `foo` is an connection variable defined in the
     * Connector's Connection.
     *
     */
    default?: unknown;
    completion?: ActionCompletion;
};

/**
 * Type is the type of the parameter. Currently only scalar types are supported, if you
 * require complex types then get in touch with support to discuss options.
 *
 */
export type type = 'string' | 'number' | 'integer' | 'boolean';

/**
 * DefinitionCommon is the common properties which are shared between Definitions for all of creation, retrieval
 * and updates.
 *
 */
export type DefinitionCommon = {
    /**
     * Name is a unique identifier for the Definition within the scope of the Connector. It is expected to both
     * human and machine-readable, i.e. "Product" or "product_variant".
     *
     */
    name: string;
    /**
     * Accept indicates which content types, expressed as MIME types, that this definition can accept. This value
     * is analogous to the Accept HTTP header, as defined in RFC 7231, section 5.3.2, except each type is defined
     * in a separate array element, rather than as a comma-separated list.
     *
     * This does not represent the content type of the schema body itself, but the data which conforms to this
     * definition. For example, an API may respond in JSON or YAML, but the schema may be a YAML-formatted JSON
     * Schema. In this case, the Definition's `accept` field could be `["application/json", "text/yaml"]` and
     * `schema.contentType` will be `application/schema+yaml`.
     *
     */
    accept: Array<string>;
    /**
     * Description is a human-friendly description of the Definition. This is typically used to describe the
     * purpose of the Definition and how it should be used.
     *
     */
    description?: string;
};

/**
 * DefinitionReference defines where another resource references this Definition.
 *
 */
export type DefinitionReference = {
    type: 'definition' | 'action' | 'trigger';
    /**
     * ID is the unique identifier of the Definition/Action/Trigger.
     */
    id: string;
    /**
     * Name is unique identifier for the Definition/Action/Trigger within the scope of the Connector. It is
     * expected to both human and machine-readable, i.e. "ProductFeature" or "stock_item".
     *
     */
    name: string;
};

export type type2 = 'definition' | 'action' | 'trigger';

/**
 * Definition describes a single definition of a type which is used by the Connector. The schema language used is
 * dependent on the media-type of the Definition, for example JSON Schema is used for media-types application/json.
 *
 */
export type Definition = {
    /**
     * ID is the unique identifier of the Definition.
     */
    id: string;
} & DefinitionCommon & {
        /**
         * URL is the location of the actual Schema definition for this Definition entity.
         *
         * The structure of this URL will be consistent across all media types for each connection, for example:
         *
         * - `https://platform.versori.com/api/schemas/v1/o/{organisation_id}/{connector_id}/{connector_version}/{definition_slug}.{media_type_ext}`
         *
         */
        url: string;
        /**
         * ReferencedBy is a list of DefinitionReference objects which defines what other entities are
         * referencing the this Definition.
         *
         */
        referencedBy?: Array<DefinitionReference>;
    };

/**
 * ActionDefinition links a Definition to an Action.
 */
export type ActionDefinition = {
    /**
     * ID is a unique identifier for the request body within the scope of the Action.
     *
     */
    id: string;
    definition: Definition;
};

/**
 * ActionHTTPRequestBody defines whether a request body is required for a particular HTTP Action, and if so which
 * Definitions are considered valid. If this value is undefined then no request body will be sent.
 *
 */
export type ActionHTTPRequestBody = {
    /**
     * Required denotes whether a request body is required for this Action.
     */
    required: boolean;
    /**
     * An Action may support one Definition per media-type, i.e. application/json or application/xml etc.
     * Attempts to link multiple Definitions with the same media-type will result in an error.
     *
     */
    definitions: Array<ActionDefinition>;
};

/**
 * ActionHTTPResponseCommon defines the common fields for an ActionHTTPResponse.
 *
 */
export type ActionHTTPResponseCommon = {
    /**
     * Status is the HTTP status code which is expected from the HTTP endpoint. If this is not defined then this
     * response is treated as the default response, i.e. if no other response matches then this response will be
     * used. An action may only have one default response and each response must have a unique status code.
     *
     */
    status?: number;
};

/**
 * ActionHTTPResponse defines what responses may be returned by the HTTP server when invoking the Action.
 *
 */
export type ActionHTTPResponse = ActionHTTPResponseCommon & {
    id: string;
    /**
     * An Action may support one Definition per media-type, i.e. application/json or application/xml etc.
     * Attempts to link multiple Definitions with the same media-type will result in an error.
     *
     */
    definitions: Array<ActionDefinition>;
};

/**
 * ActionHTTPCommon defines the common fields for all HTTP Actions.
 */
export type ActionHTTPCommon = {
    type: 'http';
    method: HTTPMethod;
    path: ActionPath;
    parameters: Array<ActionHTTPParameter>;
    requestBody?: ActionHTTPRequestBody;
    /**
     * Responses defines the expected responses from the HTTP endpoint. This is used to determine whether the
     * Action was successful or not.
     *
     */
    responses: Array<ActionHTTPResponse>;
};

/**
 * ActionHTTP defines an HTTP Action.
 */
export type ActionHTTP = ActionBase & ActionHTTPCommon;

export type Action = ActionHTTP;

/**
 * ActionPage defines a paginated list of Actions.
 */
export type ActionPage = PageInfo & {
    actions: Array<Action>;
};

/**
 * DefinitionRefId is a reference to a Definition using its ID.
 */
export type DefinitionRefId = {
    /**
     * ID is the unique identifier of the Definition.
     */
    id: string;
};

/**
 * DefinitionRefName is a reference to a Definition using its name.
 */
export type DefinitionRefName = {
    /**
     * Name is the name of the Definition.
     */
    name: string;
};

/**
 * DefinitionRef is a reference to a Definition. It is used to link a Definition to an ActionDefinition.
 */
export type DefinitionRef = DefinitionRefId | DefinitionRefName;

/**
 * ActionDefinitionCreate is used to create a new ActionDefinition using a reference to an existing Definition.
 *
 */
export type ActionDefinitionCreate = {
    definition: DefinitionRef;
};

/**
 * ActionHTTPRequestBody defines whether a request body is required for a particular HTTP Action, and if so which
 * Definitions are considered valid. If this value is undefined then no request body will be sent.
 *
 */
export type ActionHTTPRequestBodyCreate = {
    /**
     * Required denotes whether a request body is required for this Action.
     */
    required: boolean;
    /**
     * An Action may support one Definition per media-type, i.e. application/json or application/xml etc.
     * Attempts to link multiple Definitions with the same media-type will result in an error.
     *
     */
    definitions: Array<ActionDefinitionCreate>;
};

/**
 * ActionHTTPResponseCreate is the payload to create a new response for an Action.
 *
 */
export type ActionHTTPResponseCreate = ActionHTTPResponseCommon & {
    /**
     * An Action may support one Definition per media-type, i.e. application/json or application/xml etc.
     * Attempts to link multiple Definitions with the same media-type will result in an error.
     *
     */
    definitions: Array<ActionDefinitionCreate>;
};

/**
 * ActionHTTPCommon defines the common fields for creating a HTTP Action.
 */
export type ActionHTTPCommonCreate = {
    type: 'http';
    method: HTTPMethod;
    path: ActionPath;
    parameters: Array<ActionHTTPParameter>;
    requestBody?: ActionHTTPRequestBodyCreate;
    /**
     * Responses defines the expected responses from the HTTP endpoint. This is used to determine whether the
     * Action was successful or not. At least one response must be defined in order for the Action to be valid.
     *
     */
    responses: Array<ActionHTTPResponseCreate>;
};

/**
 * ActionHTTPCreate defines a new HTTP Action to be created.
 */
export type ActionHTTPCreate = ActionCommon & ActionHTTPCommonCreate;

/**
 * ActionCreate defines a new Action to be created.
 */
export type ActionCreate = ActionHTTPCreate;

/**
 * TriggerError is the payload returned when a Trigger fails validation
 */
export type TriggerError = {
    /**
     * Field is the field which failed validation. This is typically a JSON Pointer, i.e.
     * "/parameters/0/properties/id", however this is open for discussion (we should be consistent with the
     * ErrorField type).
     *
     */
    field: string;
    /**
     * Message is a human-readable description of the error. This is typically a human-readable string, i.e.
     * "The parameter 'id' is invalid".
     *
     */
    message: string;
    /**
     * Severity is the severity of the error. This is used to determine how the error should be displayed to the
     * user, i.e. a warning may be displayed in a modal dialog, whereas an error may be displayed inline.
     *
     */
    severity: 'error' | 'warning';
};

export type TriggerTypeEnum = 'http';

/**
 * TriggerCommon defines all the common fields for a Trigger.
 */
export type TriggerCommon = {
    type: TriggerTypeEnum;
    /**
     * Name is a unique identifier for the Trigger within the scope of the Connector. It is expected to both
     * human and machine-readable, i.e. "GetProduct" or "get_products", see the validation regex for more details.
     *
     */
    name: string;
    /**
     * Summary is a human-readable version of the `id` field, i.e. "Get Product" or "Get Products". This is used
     * when displaying the Trigger to users, however if omitted the `TriggerId` can be used to display to users
     * instead.
     *
     */
    summary?: string;
    /**
     * Description is a human-readable description of the Trigger. It can provide extra information to users about how
     * the Trigger operates and anything the user may need to be aware of when using it.
     *
     */
    description?: string;
};

/**
 * TriggerBase defines all the common fields for a Trigger.
 *
 */
export type TriggerBase = {
    /**
     * ID is the unique identifier of the Trigger.
     */
    id: string;
    /**
     * Errors is a list of ErrorField objects which defines the errors which may be returned by the Trigger. An
     * empty array denotes that the Trigger has been validated and no errors were found. If this field is
     * undefined then this means validation has not occurred.
     *
     */
    errors?: Array<TriggerError>;
} & TriggerCommon;

export type TriggerHTTPParameterIn = 'cookie' | 'header' | 'query';

/**
 * TriggerHTTPParameter defines a parameter which is sent to the HTTP endpoint when invoking
 * the Trigger. This may be a query parameter, header or cookie depending on the `in` field.
 *
 */
export type TriggerHTTPParameter = {
    /**
     * Name is the name of the parameter which will be sent to the HTTP endpoint.
     */
    name: string;
    in: TriggerHTTPParameterIn;
    /**
     * Required denotes whether this parameter is required.
     */
    required: boolean;
    /**
     * Type is the type of the parameter. Currently only scalar types are supported, if you
     * require complex types then get in touch with support to discuss options.
     *
     */
    type: 'string' | 'number' | 'integer' | 'boolean';
    /**
     * Default is the default value to use for the parameter if no value is provided by the
     * user. If this is not defined then the parameter will not be sent to the HTTP endpoint
     * if no value is explicitly provided by the user.
     *
     * If this value is a string, it may be templated using a Go-formatted template
     * string, i.e. `{{ .conn.foo }}` where `foo` is an connection variable defined in the
     * Connector's Connection.
     *
     */
    default?: unknown;
};

/**
 * TriggerDefinition links a Definition to a Trigger.
 */
export type TriggerDefinition = {
    /**
     * ID is a unique identifier for the request body within the scope of the Trigger.
     *
     */
    id: string;
    definition: Definition;
};

/**
 * TriggerHTTPRequestBody defines whether a request body is required for a particular HTTP Trigger, and if so which
 * Definitions are considered valid. If this value is undefined then no request body will be sent.
 *
 */
export type TriggerHTTPRequestBody = {
    /**
     * Required denotes whether a request body is required for this Trigger.
     */
    required: boolean;
    /**
     * a Trigger may support one Definition per media-type, i.e. application/json or application/xml etc.
     * Attempts to link multiple Definitions with the same media-type will result in an error.
     *
     */
    definitions: Array<TriggerDefinition>;
};

/**
 * TriggerHTTPResponseCommon defines the common fields for a TriggerHTTPResponse.
 *
 */
export type TriggerHTTPResponseCommon = {
    /**
     * Status is the HTTP status code which is expected from the HTTP endpoint. If this is not defined then this
     * response is treated as the default response, i.e. if no other response matches then this response will be
     * used. a Trigger may only have one default response and each response must have a unique status code.
     *
     */
    status?: number;
};

/**
 * TriggerHTTPResponse defines what responses may be returned by the HTTP server when invoking the Trigger.
 *
 */
export type TriggerHTTPResponse = TriggerHTTPResponseCommon & {
    id: string;
    /**
     * a Trigger may support one Definition per media-type, i.e. application/json or application/xml etc.
     * Attempts to link multiple Definitions with the same media-type will result in an error.
     *
     */
    definitions: Array<TriggerDefinition>;
};

/**
 * TriggerHTTPCommon defines the common fields for all HTTP Triggers.
 */
export type TriggerHTTPCommon = {
    type: 'http';
    method: HTTPMethod;
    parameters: Array<TriggerHTTPParameter>;
    requestBody?: TriggerHTTPRequestBody;
    /**
     * Responses defines the expected responses from the HTTP endpoint. This is used to determine whether the
     * Trigger was successful or not.
     *
     */
    responses: Array<TriggerHTTPResponse>;
};

/**
 * TriggerHTTP defines an HTTP Trigger.
 */
export type TriggerHTTP = TriggerBase & TriggerHTTPCommon;

export type Trigger = TriggerHTTP;

/**
 * TriggerPage defines a paginated list of Triggers.
 */
export type TriggerPage = PageInfo & {
    triggers: Array<Trigger>;
};

/**
 * TriggerDefinitionCreate is used to create a new TriggerDefinition using a reference to an existing Definition.
 *
 */
export type TriggerDefinitionCreate = {
    definition: DefinitionRef;
};

/**
 * TriggerHTTPRequestBody defines whether a request body is required for a particular HTTP Trigger, and if so which
 * Definitions are considered valid. If this value is undefined then no request body will be sent.
 *
 */
export type TriggerHTTPRequestBodyCreate = {
    /**
     * Required denotes whether a request body is required for this Trigger.
     */
    required: boolean;
    /**
     * a Trigger may support one Definition per media-type, i.e. application/json or application/xml etc.
     * Attempts to link multiple Definitions with the same media-type will result in an error.
     *
     */
    definitions: Array<TriggerDefinitionCreate>;
};

/**
 * TriggerHTTPResponseCreate is the payload to create a new response for a Trigger.
 *
 */
export type TriggerHTTPResponseCreate = TriggerHTTPResponseCommon & {
    /**
     * a Trigger may support one Definition per media-type, i.e. application/json or application/xml etc.
     * Attempts to link multiple Definitions with the same media-type will result in an error.
     *
     */
    definitions: Array<TriggerDefinitionCreate>;
};

/**
 * TriggerHTTPCommon defines the common fields for creating a HTTP Trigger.
 */
export type TriggerHTTPCommonCreate = {
    type: 'http';
    method: HTTPMethod;
    parameters: Array<TriggerHTTPParameter>;
    requestBody?: TriggerHTTPRequestBodyCreate;
    /**
     * Responses defines the expected responses from the HTTP endpoint. This is used to determine whether the
     * Trigger was successful or not. At least one response must be defined in order for the Trigger to be valid.
     *
     */
    responses: Array<TriggerHTTPResponseCreate>;
};

/**
 * TriggerHTTPCreate defines a new HTTP Trigger to be created.
 */
export type TriggerHTTPCreate = TriggerCommon & TriggerHTTPCommonCreate;

/**
 * TriggerCreate defines a new Trigger to be created.
 */
export type TriggerCreate = TriggerHTTPCreate;

/**
 * DefinitionPage is a paginated list of Definitions.
 */
export type DefinitionPage = PageInfo & {
    definitions: Array<Definition>;
};

/**
 * InlineSchema is a Schema which is defined inline within the Definition. This is typically used when creating or
 * updating a Definition and the actual schema payload is sent with the request. For retrieval operations, the
 * Definition will contain a URL which resolves to the Schema.
 *
 */
export type InlineSchema = {
    /**
     * ContentType is the MIME type of the Schema, i.e. application/schema+json or
     * application/schema+yaml etc. This should not be confused with the media type of the data which
     * conforms to the Schema.
     *
     * The ContentType may also include parameters as would be appropriate for the content, consumers and producers
     * should be prepared to handle this, i.e. "application/schema+json; charset=utf-8".
     *
     */
    contentType: string;
    /**
     * Schema is the actual schema definition. This is typically a JSON Schema, however other formats are supported
     * such as XML Schema.
     *
     */
    content: string;
};

export type DefinitionsCreateDefinition = DefinitionCommon & {
    schema: InlineSchema;
};

/**
 * DefinitionsCreate is the payload used to create new Definitions. Each definition can reference another
 * definition in the same request using the following syntax:
 *
 * ```
 * {
 * "$ref": "#/$defs/{definition_name}"
 * }
 * ```
 *
 * New definitions may also reference existing definitions, however they use the proper URL syntax:
 *
 * ```
 * {
 * "$ref": "https://platform.versori.com/api/schemas/v1/o/{organisation_id}/{connector_id}/{connector_version}/{definition_id}.{media_type_ext}"
 * }
 * ```
 *
 * > Note, the $refs stored in GCS are the `gs://` URLs. The API must transform the URLs to the correct public URL.
 * > Ideally, the Definition's `name` would be in the URL, but this would cause issues if a user wanted to rename a
 * > Definition, which is something I think we should support. For now using `id` is fine, but if we changed to
 * > in the future, we'd need a way to iterate over all Definitions referencing the one being renamed and update
 * > the $ref URLs.
 *
 * For referencing existing definitions, the definition name must already exist within the scope of the current
 * Connector and Version.
 *
 * Each definition must have matching `dataMediaTypes` and `schema.mediaType` values.
 *
 */
export type DefinitionsCreate = {
    definitions: Array<DefinitionsCreateDefinition>;
};

/**
 * Definitions is a list of Definition objects. This is a non-paginated list and contains all definitions related
 * to the originating request (i.e. all created Definitions in a CreateDefinitions request).
 *
 */
export type Definitions = {
    definitions: Array<Definition>;
};

/**
 * DefinitionsDelete is the payload used to delete existing Definitions.
 *
 * The `ids` and `names` fields are joined and all Definitions which match either the ID or name will be deleted.
 * However, these properties are mutually exclusive, i.e. you cannot delete the same Definition by both ID and
 * name.
 *
 * In order to delete all Definitions, the `all` field must be set to true and the `ids` and `names` fields must
 * be omitted.
 *
 */
export type DefinitionsDelete = {
    ids?: Array<string>;
    names?: Array<string>;
    /**
     * All is a flag which indicates that all Definitions should be deleted. This is mutually exclusive with the
     * `ids` and `names` fields.
     *
     */
    all?: boolean;
};

/**
 * DefinitionsDeletePreconditionFailedDefinition is returned when a Definitions cannot be deleted due to a
 * precondition failure. This is most commonly due to one or more Definitions being referenced by another entity.
 *
 */
export type DefinitionsDeletePreconditionFailedDefinition = {
    id: string;
    name: string;
    referencedBy: Array<DefinitionReference>;
};

/**
 * DefinitionPreconditionFailed is returned when a Definition cannot be deleted due to a precondition failure. This
 * is most commonly due to the Definition being referenced by another entity.
 *
 */
export type DefinitionDeletePreconditionFailed = Error & {
    definition?: DefinitionsDeletePreconditionFailedDefinition;
};

/**
 * DefinitionUpdate is the payload used to update an existing Definition.
 */
export type DefinitionUpdate = {
    /**
     * ID is the unique identifier of the Definition. This must be set for updates.
     */
    id: string;
} & DefinitionCommon & {
        schema?: InlineSchema;
    };

/**
 * Protocol describes a protocol which is supported by Versori and can be used to communicate with an external
 * system.
 *
 */
export type Protocol = {
    /**
     * ID is the unique identifier of the Protocol, this is typically only used internally and the protocol `slug`
     * is used externally.
     *
     */
    id: string;
    /**
     * Slug is human-readable unique identifier of the Protocol in kebab-case format.
     */
    slug: string;
    /**
     * Name is a human-friendly name to display for the user.
     */
    name: string;
    /**
     * Description describes the protocol in human-friendly terminology. This text may be displayed to users via a
     * help tooltip or similar.
     *
     */
    description: string;
    /**
     * IconURL provides a URL to access an icon/image which represents the protocol.
     */
    iconURL: string;
};

/**
 * ProtocolPage is a page of Protocols.
 */
export type ProtocolPage = PageInfo & {
    protocols: Array<Protocol>;
};

/**
 * Type is a unique identifier of the AuthScheme, this is a kebab-case formatted string, see
 * enum values for possible options.
 *
 */
export type AuthSchemeType =
    | 'none'
    | 'api-key'
    | 'basic-auth'
    | 'oauth2'
    | 'google-service-account'
    | 'hmac'
    | 'jwt-bearer'
    | 'custom-function'
    | 'certificate';

/**
 * AuthScheme describes an authentication scheme which is supported by Versori and can be used
 * to authenticate with an external system.
 *
 */
export type AuthScheme = {
    /**
     * ID is the unique identifier of the AuthScheme, this is typically only used internally
     * and the `slug` is used to reference the AuthScheme externally.
     *
     */
    id: string;
    type: AuthSchemeType;
    /**
     * Name is a user-friendly identifier for the AuthScheme
     */
    name: string;
    /**
     * Description describes the authentication scheme in human-friendly terminology. This text may be displayed to
     * users via a help tooltip or similar.
     *
     */
    description: string;
};

export type AuthSchemePage = PageInfo & {
    authSchemes: Array<AuthScheme>;
};

/**
 * SignedURL contains URLs to upload and download files from a storage provider.
 */
export type SignedURL = {
    /**
     * UploadURL is a URL which can be used to upload a file to a storage provider. This is
     * most-commonly a signed-url from an S3-compatible storage provider however the
     * implementation may vary. Users can use this URL in a PUT request to upload a file.
     *
     */
    uploadUrl: string;
    /**
     * URL can be used to download the file from a storage provider after it has been uploaded
     * via `uploadUrl`. This URL may be a gs:// or s3:// URL which is not accessible to the
     * public, but it may be provided back to Versori for us to access.
     *
     */
    url: string;
};

/**
 * HTTPConnectorCreate is the input to the CreateHTTPConnector endpoint.
 */
export type HTTPConnectorCreate = {
    /**
     * Name is a user-friendly identifier for a Connector
     */
    name: string;
    /**
     * BaseURL is the base URL of all HTTP Actions within the Connector.
     */
    baseUrl: string;
    connectionVariables?: Array<ConnectionVariable>;
    authSchemeConfigs: Array<AuthSchemeConfig>;
    tags?: Tags;
    public?: boolean;
};

/**
 * The format of the file to be imported.
 *
 * - `openapi` - OpenAPI 3.x specification, we may include support for 2.x in the future.
 *
 */
export type ConnectorFormat = 'openapi';

/**
 * ImportHTTPConnectorVersionMetadata defines the metadata part of the multipart/form-data request
 * when creating a new connector version.
 *
 */
export type ImportHTTPConnectorVersionMetadata = {
    format: ConnectorFormat;
    /**
     * Name of the the version to create.
     */
    version: string;
};

/**
 * HTTPConnectorFromURLCreate is the body for creating an HTTP connector using a URL to download the OpenAPI schema.
 *
 */
export type HTTPConnectorFromURLCreate = {
    /**
     * The URL to download the OpenAPI schema from.
     */
    schemaURL: string;
    /**
     * The content-type of the OpenAPI schema. 'json' or 'yaml'.
     */
    filetype?: string;
    format: ConnectorFormat;
};

/**
 * HTTPConnectorFromURLCreate is the body for creating an HTTP connector using a URL to download the OpenAPI schema.
 *
 */
export type HTTPConnectorVersionFromURLCreate = HTTPConnectorFromURLCreate & {
    /**
     * The new version to create for the connector
     */
    version: string;
};

/**
 * ImportHTTPConnectorResult defines the result of importing a Connector from an external
 * format, such as OpenAPI.
 *
 */
export type ImportHTTPConnectorResult = {
    connector: HTTPConnector;
    definitions: Array<Definition>;
    actions: Array<Action>;
    triggers: Array<Trigger>;
    messages: Array<Message>;
};

/**
 * ImportHTTPConnectorResult defines the result of importing a Connector from an external
 * format, such as OpenAPI.
 *
 */
export type ImportHTTPConnectorError = Error & {
    messages?: Array<Message>;
};

/**
 * ImportHTTPConnectorMetadata defines the metadata part of the multipart/form-data request
 * when importing a Connector from another format.
 *
 */
export type ImportHTTPConnectorMetadata = {
    format: ConnectorFormat;
};

/**
 * BigQueryConnectorCreate is the input to the CreateBigQueryConnector endpoint.
 */
export type BigQueryConnectorCreate = {
    /**
     * Name is the user-provided name of the Connector
     */
    name: string;
    /**
     * DatasetID is the ID of the BigQuery dataset, in the format "<project_id>.<dataset_name>"
     */
    datasetId?: string;
    connections: Array<ConnectionCreate>;
};

export type Parameterorganisation_id = string;

/**
 * ID is the unique identifier of the Connector.
 */
export type Parameterconnector_id = string;

export type Parametercredential_id = string;

export type Parameterconnection_id = string;

/**
 * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
 * to retrieve the latest version or the default version respectively.
 *
 */
export type Parameterversion = string;

export type Parameterfirst = number;

export type Parameterbefore = string;

export type Parameterafter = string;

export type Parametersort = string;

/**
 * Allows you to search connectors by category. You can search for connectors with multiple categories by providing
 * an array of categories.
 *
 * For example: "?categories=category1&categories=category2&categories=category3".
 *
 */
export type Parametercategories = Array<Category>;

/**
 * Allows you to search using tags. The format needs to be like `<key>:<?value>`, with multiple tags separated by a
 * `,`. Each tag needs to have a key but value is optional.
 *
 * Example: "category:e-commerce,business"
 *
 */
export type Parametertags_search = string;

export type Parameterprotocol_slug = string;

export type Parameteraction_name = string;

export type Parametertrigger_name = string;

export type Parameterdefinition_name = string;

export type ListCategoriesResponse = Array<Category>;

export type ListCategoriesError = Error;

export type ListPublicConnectorsData = {
    query?: {
        after?: string;
        before?: string;
        /**
         * Allows you to search connectors by category. You can search for connectors with multiple categories by providing
         * an array of categories.
         *
         * For example: "?categories=category1&categories=category2&categories=category3".
         *
         */
        categories?: Array<Category>;
        first?: number;
        /**
         * Name filters the returned Connectors using a case-insensitive substring-match.
         *
         */
        name?: string;
        /**
         * Protocol filters the returned Connectors using a case-insensitive substring-match.
         *
         */
        protocol?: string;
        sort?: string;
        /**
         * Allows you to search using tags. The format needs to be like `<key>:<?value>`, with multiple tags separated by a
         * `,`. Each tag needs to have a key but value is optional.
         *
         * Example: "category:e-commerce,business"
         *
         */
        tags?: string;
    };
};

export type ListPublicConnectorsResponse = ConnectorPage;

export type ListPublicConnectorsError = Error;

export type ListConnectorsData = {
    path: {
        organisation_id: string;
    };
    query?: {
        after?: string;
        before?: string;
        /**
         * Allows you to search connectors by category. You can search for connectors with multiple categories by providing
         * an array of categories.
         *
         * For example: "?categories=category1&categories=category2&categories=category3".
         *
         */
        categories?: Array<Category>;
        first?: number;
        /**
         * Name filters the returned Connectors using a case-insensitive substring-match.
         *
         */
        name?: string;
        /**
         * Protocol filters the returned Connectors using a case-insensitive substring-match.
         *
         */
        protocol?: string;
        sort?: string;
        /**
         * Allows you to search using tags. The format needs to be like `<key>:<?value>`, with multiple tags separated by a
         * `,`. Each tag needs to have a key but value is optional.
         *
         * Example: "category:e-commerce,business"
         *
         */
        tags?: string;
    };
};

export type ListConnectorsResponse = ConnectorPage;

export type ListConnectorsError = Error;

export type GetConnectorData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type GetConnectorResponse = Connector;

export type GetConnectorError = Error;

export type UpdateConnectorData = {
    body: ConnectorUpdate;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type UpdateConnectorResponse = Connector;

export type UpdateConnectorError = Error;

export type DeleteConnectorData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
    query?: {
        /**
         * Force informs the API to delete the connector even if it has active subscriptions.
         */
        force?: boolean;
    };
};

export type DeleteConnectorResponse = void;

export type DeleteConnectorError = unknown;

export type UpdateConnectorTagsData = {
    body: {
        tags?: Tags;
    };
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type UpdateConnectorTagsResponse = void;

export type UpdateConnectorTagsError = Error;

export type UpdateConnectorCategoriesData = {
    body: {
        categories?: Array<Category>;
    };
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type UpdateConnectorCategoriesResponse = void;

export type UpdateConnectorCategoriesError = Error;

export type UpsertAuthSchemeConfigData = {
    body: AuthSchemeConfig;
    path: {
        auth_scheme_config_id: string;
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type UpsertAuthSchemeConfigResponse = Connector;

export type UpsertAuthSchemeConfigError = Error;

export type DeleteAuthSchemeConfigData = {
    path: {
        auth_scheme_config_id: string;
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type DeleteAuthSchemeConfigResponse = Connector;

export type DeleteAuthSchemeConfigError = Error;

export type InitialiseOauth2ConnectionData = {
    body?: InitialiseOAuth2ConnectionRequest;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type InitialiseOauth2ConnectionResponse = InitialiseOAuth2ConnectionResponse;

export type InitialiseOauth2ConnectionError = Error;

export type ListConnectorConnectionsData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
    };
};

export type ListConnectorConnectionsResponse = ConnectorConnectionPage;

export type ListConnectorConnectionsError = Error;

export type CreateConnectorConnectionData = {
    body?: ConnectionCreate;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type CreateConnectorConnectionResponse = Connection;

export type CreateConnectorConnectionError = Error;

export type GetConnectionData = {
    path: {
        connection_id: string;
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type GetConnectionResponse = Connection;

export type GetConnectionError = Error;

export type UpdateConnectionData = {
    body: ConnectionUpdate;
    path: {
        connection_id: string;
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type UpdateConnectionResponse = Connection;

export type UpdateConnectionError = Error;

export type DeleteConnectionData = {
    path: {
        connection_id: string;
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
    query?: {
        /**
         * Force informs the API to delete the connection even if it has active subscriptions.
         *
         */
        force?: boolean;
    };
};

export type DeleteConnectionResponse = void;

export type DeleteConnectionError = Error;

export type CreateConnectorVersionData = {
    body: ConnectorVersionCreate;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type CreateConnectorVersionResponse = ConnectorVersion;

export type CreateConnectorVersionError = Error;

export type ListConnectorVersionsData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
    };
};

export type ListConnectorVersionsResponse = ConnectorVersionsPage;

export type ListConnectorVersionsError = Error;

export type GetConnectorVersionData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type GetConnectorVersionResponse = ConnectorVersion;

export type GetConnectorVersionError = Error;

export type UpdateConnectorVersionData = {
    body: ConnectorVersion;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type UpdateConnectorVersionResponse = ConnectorVersion;

export type UpdateConnectorVersionError = Error;

export type DeleteConnectorVersionData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
    query?: {
        /**
         * Force informs the API to delete the connector even if it is published or has active subscriptions.
         *
         */
        force?: boolean;
    };
};

export type DeleteConnectorVersionResponse = void;

export type DeleteConnectorVersionError = Error;

export type ImportPublicConnectorVersionData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type ImportPublicConnectorVersionResponse = Connector;

export type ImportPublicConnectorVersionError = Error;

export type PublishConnectorData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type PublishConnectorResponse2 = PublishConnectorResponse;

export type PublishConnectorError = Error;

export type UnpublishConnectorData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type UnpublishConnectorResponse2 = UnpublishConnectorResponse;

export type UnpublishConnectorError = Error;

export type GetActionsData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
        /**
         * Name filters Actions by name using a case-insensitive substring-match.
         *
         */
        name?: string;
    };
};

export type GetActionsResponse = ActionPage;

export type GetActionsError = Error;

export type CreateActionData = {
    body: ActionCreate;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type CreateActionResponse = Action;

export type CreateActionError = Error;

export type GetActionData = {
    path: {
        action_name: string;
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type GetActionResponse = Action;

export type GetActionError = Error;

export type UpdateActionData = {
    body: Action;
    path: {
        action_name: string;
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type UpdateActionResponse = Action;

export type UpdateActionError = Error;

export type DeleteActionData = {
    path: {
        action_name: string;
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type DeleteActionResponse = void;

export type DeleteActionError = Error;

export type GetTriggersData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
        /**
         * Name filters Triggers by name using a case-insensitive substring-match.
         *
         */
        name?: string;
    };
};

export type GetTriggersResponse = TriggerPage;

export type GetTriggersError = Error;

export type CreateTriggerData = {
    body: TriggerCreate;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type CreateTriggerResponse = Trigger;

export type CreateTriggerError = Error;

export type GetTriggerData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        trigger_name: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type GetTriggerResponse = Trigger;

export type GetTriggerError = Error;

export type UpdateTriggerData = {
    body: Trigger;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        trigger_name: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type UpdateTriggerResponse = Trigger;

export type UpdateTriggerError = Error;

export type DeleteTriggerData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        trigger_name: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type DeleteTriggerResponse = void;

export type DeleteTriggerError = Error;

export type GetDefinitionsData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
        /**
         * Name filters the returned Definitions using a case-insensitive substring-match.
         *
         */
        name?: string;
    };
};

export type GetDefinitionsResponse = DefinitionPage;

export type GetDefinitionsError = Error;

export type CreateDefinitionsData = {
    body: DefinitionsCreate;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type CreateDefinitionsResponse = Definitions;

export type CreateDefinitionsError = Error;

export type DeleteDefinitionsData = {
    body: DefinitionsDelete;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
    query?: {
        /**
         * Force deletes the specified Definitions, even if they are referenced by other Definitions. This will trigger
         * validation errors for any Definitions that reference the deleted Definitions.
         *
         */
        force?: boolean;
    };
};

export type DeleteDefinitionsResponse = void;

export type DeleteDefinitionsError = DefinitionDeletePreconditionFailed | Error;

export type GetDefinitionData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        definition_name: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type GetDefinitionResponse = Definition;

export type GetDefinitionError = Error;

export type UpdateDefinitionData = {
    body: DefinitionUpdate;
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        definition_name: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type UpdateDefinitionResponse = Definition;

export type UpdateDefinitionError = Error;

export type DeleteDefinitionData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        definition_name: string;
        organisation_id: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
    query?: {
        /**
         * Force deletes the Definition, even if it is referenced by other Definitions. This will cause validation
         * errors on the referring Definitions which will need to be fixed before a Connector may be published.
         *
         */
        force?: boolean;
    };
};

export type DeleteDefinitionResponse = void;

export type DeleteDefinitionError = DefinitionDeletePreconditionFailed | Error;

export type ListProtocolsData = {
    path: {
        organisation_id: string;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
    };
};

export type ListProtocolsResponse = ProtocolPage;

export type ListProtocolsError = Error;

export type ListAuthSchemesData = {
    path: {
        organisation_id: string;
        protocol_slug: string;
    };
};

export type ListAuthSchemesResponse = AuthSchemePage;

export type ListAuthSchemesError = Error;

export type GetProtocolUploadUrlData = {
    path: {
        organisation_id: string;
        protocol_slug: string;
    };
};

export type GetProtocolUploadUrlResponse = SignedURL;

export type GetProtocolUploadUrlError = Error;

export type CreateHttpConnectorData = {
    body: HTTPConnectorCreate;
    path: {
        organisation_id: string;
    };
};

export type CreateHttpConnectorResponse = HTTPConnector;

export type CreateHttpConnectorError = Error;

export type ImportHttpConnectorVersionData = {
    body: {
        /**
         * The file to be imported.
         */
        file?: Blob | File;
        metadata?: ImportHTTPConnectorVersionMetadata;
    };
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
    };
};

export type ImportHttpConnectorVersionResponse = ImportHTTPConnectorResult;

export type ImportHttpConnectorVersionError = ImportHTTPConnectorError | Error;

export type ImportHttpConnectorData = {
    body: {
        /**
         * The file to be imported.
         */
        file?: Blob | File;
        metadata?: ImportHTTPConnectorMetadata;
    };
    path: {
        organisation_id: string;
    };
};

export type ImportHttpConnectorResponse = ImportHTTPConnectorResult;

export type ImportHttpConnectorError = ImportHTTPConnectorError | Error;

export type CreateBigQueryConnectorData = {
    body: BigQueryConnectorCreate;
    path: {
        organisation_id: string;
    };
};

export type CreateBigQueryConnectorResponse = BigQueryConnector;

export type CreateBigQueryConnectorError = Error;

export type GetRawSchemaData = {
    path: {
        /**
         * ID is the unique identifier of the Connector.
         */
        connector_id: string;
        organisation_id: string;
        schema_filename: string;
        /**
         * Version is the version name of the Connector to retrieve. The reserved names "latest" and "default" may be used
         * to retrieve the latest version or the default version respectively.
         *
         */
        version: string;
    };
};

export type GetRawSchemaResponse =
    | {
          [key: string]: unknown;
      }
    | boolean;

export type GetRawSchemaError = Error;
