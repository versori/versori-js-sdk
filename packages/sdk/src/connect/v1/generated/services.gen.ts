// This file is auto-generated by @hey-api/openapi-ts

import { createClient, createConfig, type Options, formDataBodySerializer } from '@hey-api/client-fetch';
import type { ListCategoriesError, ListCategoriesResponse, ListPublicConnectorsData, ListPublicConnectorsError, ListPublicConnectorsResponse, ListConnectorsData, ListConnectorsError, ListConnectorsResponse, GetConnectorData, GetConnectorError, GetConnectorResponse, UpdateConnectorData, UpdateConnectorError, UpdateConnectorResponse, DeleteConnectorData, DeleteConnectorError, DeleteConnectorResponse, UpdateConnectorTagsData, UpdateConnectorTagsError, UpdateConnectorTagsResponse, UpdateConnectorCategoriesData, UpdateConnectorCategoriesError, UpdateConnectorCategoriesResponse, UpsertAuthSchemeConfigData, UpsertAuthSchemeConfigError, UpsertAuthSchemeConfigResponse, DeleteAuthSchemeConfigData, DeleteAuthSchemeConfigError, DeleteAuthSchemeConfigResponse, InitialiseOauth2ConnectionData, InitialiseOauth2ConnectionError, InitialiseOauth2ConnectionResponse, ListConnectorConnectionsData, ListConnectorConnectionsError, ListConnectorConnectionsResponse, CreateConnectorConnectionData, CreateConnectorConnectionError, CreateConnectorConnectionResponse, GetConnectionData, GetConnectionError, GetConnectionResponse, UpdateConnectionData, UpdateConnectionError, UpdateConnectionResponse, DeleteConnectionData, DeleteConnectionError, DeleteConnectionResponse, CreateConnectorVersionData, CreateConnectorVersionError, CreateConnectorVersionResponse, ListConnectorVersionsData, ListConnectorVersionsError, ListConnectorVersionsResponse, GetConnectorVersionData, GetConnectorVersionError, GetConnectorVersionResponse, UpdateConnectorVersionData, UpdateConnectorVersionError, UpdateConnectorVersionResponse, DeleteConnectorVersionData, DeleteConnectorVersionError, DeleteConnectorVersionResponse, ImportPublicConnectorVersionData, ImportPublicConnectorVersionError, ImportPublicConnectorVersionResponse, PublishConnectorData, PublishConnectorError, PublishConnectorResponse2, UnpublishConnectorData, UnpublishConnectorError, UnpublishConnectorResponse2, GetActionsData, GetActionsError, GetActionsResponse, CreateActionData, CreateActionError, CreateActionResponse, GetActionData, GetActionError, GetActionResponse, UpdateActionData, UpdateActionError, UpdateActionResponse, DeleteActionData, DeleteActionError, DeleteActionResponse, GetTriggersData, GetTriggersError, GetTriggersResponse, CreateTriggerData, CreateTriggerError, CreateTriggerResponse, GetTriggerData, GetTriggerError, GetTriggerResponse, UpdateTriggerData, UpdateTriggerError, UpdateTriggerResponse, DeleteTriggerData, DeleteTriggerError, DeleteTriggerResponse, GetDefinitionsData, GetDefinitionsError, GetDefinitionsResponse, CreateDefinitionsData, CreateDefinitionsError, CreateDefinitionsResponse, DeleteDefinitionsData, DeleteDefinitionsError, DeleteDefinitionsResponse, GetDefinitionData, GetDefinitionError, GetDefinitionResponse, UpdateDefinitionData, UpdateDefinitionError, UpdateDefinitionResponse, DeleteDefinitionData, DeleteDefinitionError, DeleteDefinitionResponse, ListProtocolsData, ListProtocolsError, ListProtocolsResponse, ListAuthSchemesData, ListAuthSchemesError, ListAuthSchemesResponse, GetProtocolUploadUrlData, GetProtocolUploadUrlError, GetProtocolUploadUrlResponse, CreateHttpConnectorData, CreateHttpConnectorError, CreateHttpConnectorResponse, ImportHttpConnectorVersionData, ImportHttpConnectorVersionError, ImportHttpConnectorVersionResponse, ImportHttpConnectorData, ImportHttpConnectorError, ImportHttpConnectorResponse, CreateBigQueryConnectorData, CreateBigQueryConnectorError, CreateBigQueryConnectorResponse, GetRawSchemaData, GetRawSchemaError, GetRawSchemaResponse } from './types.gen';

export const client = createClient(createConfig());

/**
 * List all available categories
 * ListCategories returns a list of all available categories.
 *
 */
export const listCategories = <ThrowOnError extends boolean = false>(options?: Options<unknown, ThrowOnError>) => { return (options?.client ?? client).get<ListCategoriesResponse, ListCategoriesError, ThrowOnError>({
    ...options,
    url: '/categories'
}); };

/**
 * List Public Connectors
 * ListConnectors returns a paginated list of all public Connectors, ordered with most recently updated first.
 *
 * Customising the sort behaviour is not currently supported but may be added in the future. Similarly with
 * filtering, this will be implemented in a future release.
 *
 */
export const listPublicConnectors = <ThrowOnError extends boolean = false>(options?: Options<ListPublicConnectorsData, ThrowOnError>) => { return (options?.client ?? client).get<ListPublicConnectorsResponse, ListPublicConnectorsError, ThrowOnError>({
    ...options,
    url: '/connectors'
}); };

/**
 * List Connectors
 * ListConnectors returns a paginated list of Connectors, ordered with most recently updated first.
 *
 * Customising the sort behaviour is not currently supported but may be added in the future. Similarly with
 * filtering, this will be implemented in a future release.
 *
 */
export const listConnectors = <ThrowOnError extends boolean = false>(options: Options<ListConnectorsData, ThrowOnError>) => { return (options?.client ?? client).get<ListConnectorsResponse, ListConnectorsError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors'
}); };

/**
 * Get Connector
 * GetConnector returns a single Connector for the specified ID. If one does not exist then a 404 will be returned.
 *
 */
export const getConnector = <ThrowOnError extends boolean = false>(options: Options<GetConnectorData, ThrowOnError>) => { return (options?.client ?? client).get<GetConnectorResponse, GetConnectorError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}'
}); };

/**
 * Update Connector
 * UpdateConnector updates a Connector with the specified request body. All mutable fields are updated as per the
 * request body, and the `updatedAt` field is set to the current time. Any missing fields will be unset unless this
 * causes a validation error, in which case the request will fail with a 400 Bad Request response.
 *
 */
export const updateConnector = <ThrowOnError extends boolean = false>(options: Options<UpdateConnectorData, ThrowOnError>) => { return (options?.client ?? client).put<UpdateConnectorResponse, UpdateConnectorError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}'
}); };

/**
 * Delete Connector
 * DeleteConnector deletes a Connector with the specified ID. If the Connector is in use by another product then a
 * 409 Conflict response will be returned. If the Connector does not exist then a 404 Not Found response will be
 * returned.
 *
 * A connector can be forcefully deleted with the `force` query parameter. This will delete the connector even if
 * it is in use by another product. This should only be used in exceptional circumstances and may cause other
 * issues externally.
 *
 */
export const deleteConnector = <ThrowOnError extends boolean = false>(options: Options<DeleteConnectorData, ThrowOnError>) => { return (options?.client ?? client).delete<DeleteConnectorResponse, DeleteConnectorError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}'
}); };

/**
 * Update Connector Tags
 * UpdateConnectorTags updates the tags for a Connector. The tags are replaced with the new tags provided in the
 * request body.
 *
 */
export const updateConnectorTags = <ThrowOnError extends boolean = false>(options: Options<UpdateConnectorTagsData, ThrowOnError>) => { return (options?.client ?? client).put<UpdateConnectorTagsResponse, UpdateConnectorTagsError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/tags'
}); };

/**
 * Update Connector Categories
 * UpdateConnectorCategories updates the categories for a Connector. The categories are replaced with the new
 * categories provided in the request body.
 *
 */
export const updateConnectorCategories = <ThrowOnError extends boolean = false>(options: Options<UpdateConnectorCategoriesData, ThrowOnError>) => { return (options?.client ?? client).put<UpdateConnectorCategoriesResponse, UpdateConnectorCategoriesError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/categories'
}); };

/**
 * Upsert Auth Scheme Config to Connector
 * UpsertAuthSchemeConfig updates or adds an AuthSchemeConfig to the specified Connector. The ID must be generated
 * by the client and be unique across all other AuthSchemeConfig objects for this connector.
 *
 */
export const upsertAuthSchemeConfig = <ThrowOnError extends boolean = false>(options: Options<UpsertAuthSchemeConfigData, ThrowOnError>) => { return (options?.client ?? client).put<UpsertAuthSchemeConfigResponse, UpsertAuthSchemeConfigError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/auth-scheme-configs/{auth_scheme_config_id}'
}); };

/**
 * Delete Auth Scheme Config
 * DeleteAuthSchemeConfig deletes an AuthSchemeConfig from the specified Connector. Any Connections created via
 * this AuthSchemeConfig will remain, however refreshable credentials (i.e. OAuth 2.0/Custom Function) will no
 * longer be able to refresh and will become invalid after the next expiry.
 *
 */
export const deleteAuthSchemeConfig = <ThrowOnError extends boolean = false>(options: Options<DeleteAuthSchemeConfigData, ThrowOnError>) => { return (options?.client ?? client).delete<DeleteAuthSchemeConfigResponse, DeleteAuthSchemeConfigError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/auth-scheme-configs/{auth_scheme_config_id}'
}); };

/**
 * Initialise OAuth 2.0 Connection
 * InitialiseOAuth2Connection returns a URL to redirect the user to an OAuth 2.0 Provider's Authorize endpoint.
 *
 * Only URLs constructed via this API can be used to connect to an OAuth 2.0 connector within
 * Versori, since a `state` parameter is generated and validated upon redirection to the
 * redirect_uri.
 *
 * Additional query parameters can be added to the resultant URL via the `additionalParams`
 * property in the body. In addition to the standard parameters defined in the body, this API
 * adds the following parameters:
 *
 * - `redirect_uri`: The URI to redirect the user to after the OAuth 2.0 Provider has
 * authenticated the user.
 * - `state`: A secure string generated by the API to authenticate requests to the redirect URI.
 * - `prompt`: See documentation on the `prompt` property of the request body.
 * - `scope`: See documentation on the `scopes` property of the request body.
 * - `response_type`: The response type to use. This is always `code` for OAuth 2.0.
 * - `client_id`: The client ID provided by the request body, this must match the client ID
 * which is stored under the provided `credentialId` otherwise the handling of the redirect
 * request will fail.
 *
 * Full details on the standard parameters can be found in the OIDC Core specification:
 * https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
 *
 */
export const initialiseOauth2Connection = <ThrowOnError extends boolean = false>(options: Options<InitialiseOauth2ConnectionData, ThrowOnError>) => { return (options?.client ?? client).post<InitialiseOauth2ConnectionResponse, InitialiseOauth2ConnectionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/oauth2/initialise'
}); };

/**
 * List Connector Connections
 * ListConnectorConnections returns a paginated list of Connections, ordered with most recently updated first.
 * Customising the sort behaviour is not currently supported but may be added in the future. Similarly with
 * filtering, this will be implemented in a future release.
 *
 */
export const listConnectorConnections = <ThrowOnError extends boolean = false>(options: Options<ListConnectorConnectionsData, ThrowOnError>) => { return (options?.client ?? client).get<ListConnectorConnectionsResponse, ListConnectorConnectionsError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/connections'
}); };

/**
 * Create a new connection.
 * CreateConnectorConnection creates a new connection for the given connector.
 *
 * It will also optionally create the credentials for the connection.
 *
 */
export const createConnectorConnection = <ThrowOnError extends boolean = false>(options: Options<CreateConnectorConnectionData, ThrowOnError>) => { return (options?.client ?? client).post<CreateConnectorConnectionResponse, CreateConnectorConnectionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/connections'
}); };

/**
 * Get Connection
 * GetConnection returns a specific Connection within a Connector.
 *
 */
export const getConnection = <ThrowOnError extends boolean = false>(options: Options<GetConnectionData, ThrowOnError>) => { return (options?.client ?? client).get<GetConnectionResponse, GetConnectionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/connections/{connection_id}'
}); };

/**
 * Update Connection
 * UpdateConnection updates an Connection. Credentials may be reordered and AuthSchemeConfigs updated, however
 * actual Credentials may only be updated via the `UpdateCredential` operation.
 *
 */
export const updateConnection = <ThrowOnError extends boolean = false>(options: Options<UpdateConnectionData, ThrowOnError>) => { return (options?.client ?? client).put<UpdateConnectionResponse, UpdateConnectionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/connections/{connection_id}'
}); };

/**
 * Delete Connection
 * DeleteConnection deletes an Connection.
 *
 */
export const deleteConnection = <ThrowOnError extends boolean = false>(options: Options<DeleteConnectionData, ThrowOnError>) => { return (options?.client ?? client).delete<DeleteConnectionResponse, DeleteConnectionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/connections/{connection_id}'
}); };

/**
 * Create Connector Version
 * CreateConnectorVersion creates a new ConnectorVersion for the specified Connector. The ConnectorVersion will be
 * created as a draft (i.e. publishedAt will be `null`).
 *
 */
export const createConnectorVersion = <ThrowOnError extends boolean = false>(options: Options<CreateConnectorVersionData, ThrowOnError>) => { return (options?.client ?? client).post<CreateConnectorVersionResponse, CreateConnectorVersionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions'
}); };

/**
 * List Connector Versions
 * ListConnectorVersions returns a page of ConnectorVersions ordered by most recently updated first. Customising
 * the sort behaviour is not currently supported but may be added in the future. Similarly with filtering, this
 * will be implemented in a future release.
 *
 */
export const listConnectorVersions = <ThrowOnError extends boolean = false>(options: Options<ListConnectorVersionsData, ThrowOnError>) => { return (options?.client ?? client).get<ListConnectorVersionsResponse, ListConnectorVersionsError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions'
}); };

/**
 * Get Connector Version
 * GetConnectorVersion returns a single ConnectorVersion for the specified ID. If one does not exist then a 404
 * will be returned.
 *
 */
export const getConnectorVersion = <ThrowOnError extends boolean = false>(options: Options<GetConnectorVersionData, ThrowOnError>) => { return (options?.client ?? client).get<GetConnectorVersionResponse, GetConnectorVersionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}'
}); };

/**
 * Update Connector Version
 * UpdateConnectorVersion updates a ConnectorVersion with the specified request body. Changes to read-only fields
 * will result in a 400 Bad Request response.
 *
 */
export const updateConnectorVersion = <ThrowOnError extends boolean = false>(options: Options<UpdateConnectorVersionData, ThrowOnError>) => { return (options?.client ?? client).put<UpdateConnectorVersionResponse, UpdateConnectorVersionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}'
}); };

/**
 * Delete Connector Version
 * DeleteConnectorVersion deletes a ConnectorVersion with the specified version name.
 *
 * By default, a ConnectorVersion may only be deleted if it is not published, however this behaviour can be
 * overridden with the `force` query parameter. This should only be used in exceptional circumstances as it may
 * cause issues with any active subscriptions.
 *
 */
export const deleteConnectorVersion = <ThrowOnError extends boolean = false>(options: Options<DeleteConnectorVersionData, ThrowOnError>) => { return (options?.client ?? client).delete<DeleteConnectorVersionResponse, DeleteConnectorVersionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}'
}); };

/**
 * Import Public Connector Version
 * ImportPublicConnectorVersion imports a public ConnectorVersion into the users organisation.
 *
 * The ConnectorVersion will be created as a draft (i.e. publishedAt will be `null`).
 *
 */
export const importPublicConnectorVersion = <ThrowOnError extends boolean = false>(options: Options<ImportPublicConnectorVersionData, ThrowOnError>) => { return (options?.client ?? client).post<ImportPublicConnectorVersionResponse, ImportPublicConnectorVersionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/library/import'
}); };

/**
 * Publish Connector
 * PublishConnector validates and publishes the specified connector version.
 */
export const publishConnector = <ThrowOnError extends boolean = false>(options: Options<PublishConnectorData, ThrowOnError>) => { return (options?.client ?? client).post<PublishConnectorResponse2, PublishConnectorError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/publish'
}); };

/**
 * Unpublish Connector
 * UnpublishConnector un-publishes a published Connector Version. A Connector must be unpublished before it can be
 * deleted, and can only be unpublished if there are no subscriptions to it (i.e. used in a live integration).
 *
 */
export const unpublishConnector = <ThrowOnError extends boolean = false>(options: Options<UnpublishConnectorData, ThrowOnError>) => { return (options?.client ?? client).post<UnpublishConnectorResponse2, UnpublishConnectorError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/unpublish'
}); };

/**
 * Get Actions
 * GetActions returns a paginated list of Actions for the specified ConnectorVersion.
 *
 */
export const getActions = <ThrowOnError extends boolean = false>(options: Options<GetActionsData, ThrowOnError>) => { return (options?.client ?? client).get<GetActionsResponse, GetActionsError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/actions'
}); };

/**
 * Create Action
 * CreateAction creates a new Action for the specified ConnectorVersion. The Action type must be compatible with
 * the protocol of the Connector, otherwise a 400 Bad Request response will be returned.
 *
 */
export const createAction = <ThrowOnError extends boolean = false>(options: Options<CreateActionData, ThrowOnError>) => { return (options?.client ?? client).post<CreateActionResponse, CreateActionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/actions'
}); };

/**
 * Get Action
 * GetAction returns the Action for the specified parameters.
 *
 */
export const getAction = <ThrowOnError extends boolean = false>(options: Options<GetActionData, ThrowOnError>) => { return (options?.client ?? client).get<GetActionResponse, GetActionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/actions/{action_name}'
}); };

/**
 * Update Action
 * UpdateAction updates the specified Action with the request body.
 *
 */
export const updateAction = <ThrowOnError extends boolean = false>(options: Options<UpdateActionData, ThrowOnError>) => { return (options?.client ?? client).put<UpdateActionResponse, UpdateActionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/actions/{action_name}'
}); };

/**
 * Delete Action
 * DeleteAction deletes the specified Action.
 *
 */
export const deleteAction = <ThrowOnError extends boolean = false>(options: Options<DeleteActionData, ThrowOnError>) => { return (options?.client ?? client).delete<DeleteActionResponse, DeleteActionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/actions/{action_name}'
}); };

/**
 * Get Triggers
 * GetTriggers returns a paginated list of Triggers for the specified ConnectorVersion.
 *
 */
export const getTriggers = <ThrowOnError extends boolean = false>(options: Options<GetTriggersData, ThrowOnError>) => { return (options?.client ?? client).get<GetTriggersResponse, GetTriggersError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/triggers'
}); };

/**
 * Create Trigger
 * CreateTrigger creates a new Trigger for the specified ConnectorVersion. The Trigger type must be compatible with
 * the protocol of the Connector, otherwise a 400 Bad Request response will be returned.
 *
 */
export const createTrigger = <ThrowOnError extends boolean = false>(options: Options<CreateTriggerData, ThrowOnError>) => { return (options?.client ?? client).post<CreateTriggerResponse, CreateTriggerError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/triggers'
}); };

/**
 * Get Trigger
 * GetTrigger returns the Trigger for the specified parameters.
 *
 */
export const getTrigger = <ThrowOnError extends boolean = false>(options: Options<GetTriggerData, ThrowOnError>) => { return (options?.client ?? client).get<GetTriggerResponse, GetTriggerError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/triggers/{trigger_name}'
}); };

/**
 * Update Trigger
 * UpdateTrigger updates the specified Trigger with the request body.
 *
 */
export const updateTrigger = <ThrowOnError extends boolean = false>(options: Options<UpdateTriggerData, ThrowOnError>) => { return (options?.client ?? client).put<UpdateTriggerResponse, UpdateTriggerError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/triggers/{trigger_name}'
}); };

/**
 * Delete Trigger
 * DeleteTrigger deletes the specified Trigger.
 *
 */
export const deleteTrigger = <ThrowOnError extends boolean = false>(options: Options<DeleteTriggerData, ThrowOnError>) => { return (options?.client ?? client).delete<DeleteTriggerResponse, DeleteTriggerError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/triggers/{trigger_name}'
}); };

/**
 * Get Definitions
 * GetDefinitions returns a paginated list of Definitions for the specified ConnectorVersion.
 *
 */
export const getDefinitions = <ThrowOnError extends boolean = false>(options: Options<GetDefinitionsData, ThrowOnError>) => { return (options?.client ?? client).get<GetDefinitionsResponse, GetDefinitionsError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/definitions'
}); };

/**
 * Create Definitions
 * CreateDefinitions creates one-many new Definitions for the specified ConnectorVersion. For simple cases, it's
 * recommended to create Definitions individually, however this endpoint can be used to create multiple Definitions
 * for cases where one Definition references another.
 *
 * Definitions with cyclic references can be created in one API call, see the documentation for the
 * `DefinitionCreate` schema for more info.
 *
 */
export const createDefinitions = <ThrowOnError extends boolean = false>(options: Options<CreateDefinitionsData, ThrowOnError>) => { return (options?.client ?? client).post<CreateDefinitionsResponse, CreateDefinitionsError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/definitions'
}); };

/**
 * Delete Definitions
 * DeleteDefinitions deletes the specified Definitions as per the request body.
 *
 */
export const deleteDefinitions = <ThrowOnError extends boolean = false>(options: Options<DeleteDefinitionsData, ThrowOnError>) => { return (options?.client ?? client).delete<DeleteDefinitionsResponse, DeleteDefinitionsError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/definitions'
}); };

/**
 * Get Definition
 * GetDefinition returns the Definition for the specified parameters.
 *
 */
export const getDefinition = <ThrowOnError extends boolean = false>(options: Options<GetDefinitionData, ThrowOnError>) => { return (options?.client ?? client).get<GetDefinitionResponse, GetDefinitionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/definitions/{definition_name}'
}); };

/**
 * Update Definition
 * UpdateDefinition updates the specified Definition with the request body.
 *
 */
export const updateDefinition = <ThrowOnError extends boolean = false>(options: Options<UpdateDefinitionData, ThrowOnError>) => { return (options?.client ?? client).put<UpdateDefinitionResponse, UpdateDefinitionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/definitions/{definition_name}'
}); };

/**
 * Delete Definition
 * DeleteDefinition deletes the specified Definition.
 *
 */
export const deleteDefinition = <ThrowOnError extends boolean = false>(options: Options<DeleteDefinitionData, ThrowOnError>) => { return (options?.client ?? client).delete<DeleteDefinitionResponse, DeleteDefinitionError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/connectors/{connector_id}/versions/{version}/definitions/{definition_name}'
}); };

/**
 * List Protocols
 * ListProtocols returns all the supported Protocols for this organisation.
 *
 * If a desired Protocol is not listed then please contact support@versori.com to request it be added.
 *
 */
export const listProtocols = <ThrowOnError extends boolean = false>(options: Options<ListProtocolsData, ThrowOnError>) => { return (options?.client ?? client).get<ListProtocolsResponse, ListProtocolsError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/protocols'
}); };

/**
 * List Auth Schemes
 * ListAuthSchemes returns all the supported Auth Schemes for the provided Protocol within this organisation. If a
 * desired Auth Scheme is not listed then please contact support@versori.io to request it be added.
 *
 */
export const listAuthSchemes = <ThrowOnError extends boolean = false>(options: Options<ListAuthSchemesData, ThrowOnError>) => { return (options?.client ?? client).get<ListAuthSchemesResponse, ListAuthSchemesError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/protocols/{protocol_slug}/auth-schemes'
}); };

/**
 * Get Protocol Upload URL
 * GetProtocolUploadURL returns a Signed URL to an object storage service which can be used to upload a file via a
 * PUT request. This is used as a precursor to importing a Connector from a file, which expects a URL. If the user
 * already has a publicly accessible URL to a file then this step can be skipped.
 *
 * The URL will be valid for 5 minutes and can only be used once.
 *
 * The content_type and content_length parameters are required to enforce any size and content type restrictions,
 * and these must be sent with the PUT request to the returned URL.
 *
 */
export const getProtocolUploadUrl = <ThrowOnError extends boolean = false>(options: Options<GetProtocolUploadUrlData, ThrowOnError>) => { return (options?.client ?? client).get<GetProtocolUploadUrlResponse, GetProtocolUploadUrlError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/protocols/{protocol_slug}/upload-url'
}); };

/**
 * Create HTTP Connector
 * CreateHTTPConnector creates a new HTTP Connector. By default the Connector will be created in a draft state and
 * will need to be published before it can be used by other Versori products.
 *
 */
export const createHttpConnector = <ThrowOnError extends boolean = false>(options: Options<CreateHttpConnectorData, ThrowOnError>) => { return (options?.client ?? client).post<CreateHttpConnectorResponse, CreateHttpConnectorError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/protocols/http/connectors'
}); };

/**
 * Create a new new connector version.
 * ImportHTTPConnectorVersion is used to create a new version for the connector.
 *
 * This uses a new OpenAPI spec to create the new version.
 *
 */
export const importHttpConnectorVersion = <ThrowOnError extends boolean = false>(options: Options<ImportHttpConnectorVersionData, ThrowOnError>) => { return (options?.client ?? client).post<ImportHttpConnectorVersionResponse, ImportHttpConnectorVersionError, ThrowOnError>({
    ...options,
    ...formDataBodySerializer,
    headers: {
        'Content-Type': null,
        ...options?.headers
    },
    url: '/o/{organisation_id}/connector/{connector_id}/http/import'
}); };

/**
 * Import HTTP Connector
 * ImportHTTPConnector imports a Connector from another format such as OpenAPI or Postman Collections.
 *
 * The Connector will be created in a draft state and will need to be published before it can be used in a live
 * board.
 *
 */
export const importHttpConnector = <ThrowOnError extends boolean = false>(options: Options<ImportHttpConnectorData, ThrowOnError>) => { return (options?.client ?? client).post<ImportHttpConnectorResponse, ImportHttpConnectorError, ThrowOnError>({
    ...options,
    ...formDataBodySerializer,
    headers: {
        'Content-Type': null,
        ...options?.headers
    },
    url: '/o/{organisation_id}/protocols/http/import'
}); };

/**
 * Create BigQuery Connector
 * CreateBigQueryConnector creates a new BigQuery Connector. By default the Connector will be created in a draft
 * state and will need to be published before it can be used by other Versori products.
 *
 */
export const createBigQueryConnector = <ThrowOnError extends boolean = false>(options: Options<CreateBigQueryConnectorData, ThrowOnError>) => { return (options?.client ?? client).post<CreateBigQueryConnectorResponse, CreateBigQueryConnectorError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/protocols/bigquery/connectors'
}); };

/**
 * Get a Raw Schema
 */
export const getRawSchema = <ThrowOnError extends boolean = false>(options: Options<GetRawSchemaData, ThrowOnError>) => { return (options?.client ?? client).get<GetRawSchemaResponse, GetRawSchemaError, ThrowOnError>({
    ...options,
    url: '/o/{organisation_id}/schemas/{connector_id}/{version}/{schema_filename}'
}); };