// This file is auto-generated by @hey-api/openapi-ts

export type Activation = {
    id: string;
    user: EndUser;
    environment?: ProjectEnvironment;
    connections?: Array<Connection>;
    dynamicVariables?: DynamicVariables;
};

/**
 * ActivationCreate is the request payload to activate an environment for End User
 *
 */
export type ActivationCreate = {
    /**
     * This userID could be the id or the external_id of the user that is being activated.
     */
    userId: string;
    environmentId: string;
    connections: Array<{
        connectionTemplateId: TemplateID;
        connection?: ConnectionCreate;
        /**
         * The id of an existing connection to be linked to the environment. If 'connection' is provided, this field is ignored.
         */
        existingConnectionId?: string;
    }>;
    dynamicVariables?: DynamicVariables;
};

/**
 * ConnectionCreate defines the connection to create.
 */
export type ConnectionCreate = {
    /**
     * Name is the name of the Connection.
     */
    name: string;
    credentials: ConnectionCredentialsCreate;
    variables: Array<ConnectionVariable>;
    /**
     * BaseURL is the base URL for the connection. This allows you to override the baseURL for the system being connected to.
     * An example is where the system's baseURL is https://shopifyplaceholder.com and you want to connect to your own shopify
     * which is at https://myshopify.com. Everything after the top-level domain will be ignored. If the scheme is missing, then
     * https:// will be used.
     *
     */
    baseUrl?: string;
};

export type EnvSystemConnectionCreate = {
    connectionTemplateId: TemplateID;
    connection: ConnectionCreate;
};

/**
 * LinkConnectionEnvironment is the request payload to link an existing connection to an environment.
 *
 */
export type LinkConnectionEnvironment = {
    connectionTemplateId: TemplateID;
};

/**
 * ProjectCreate is the request body for creating a new Project.
 */
export type ProjectCreate = {
    /**
     * Name is the name of the project.
     */
    name: string;
    /**
     * The unique identifier for the project.
     */
    id?: string;
};

/**
 * ProjectUpdate is the request body for updating a Project.
 */
export type ProjectUpdate = {
    /**
     * Name is the name of the project.
     */
    name: string;
};

/**
 * ProjectsList is the response body for listing all projects.
 */
export type ProjectsList = {
    projects: Array<ProjectSummary>;
};

/**
 * The Project represents a deployable unit within our platform that includes both the functional components (files) and configuration. It serves as the backbone of custom or predefined functionalities, allowing organizations to create, update, and manage APIs and projects.
 *
 */
export type ProjectSummary = {
    /**
     * The unique identifier for the project.
     */
    id: string;
    name: string;
    createdAt: string;
    /**
     * List of environments for the project.
     *
     */
    environments: Array<ProjectEnvironment>;
};

/**
 * DynamicVariablesSchema is the JSON schema for the project's dynamic variables.
 *
 */
export type DynamicVariablesSchema = {
    [key: string]: unknown;
};

/**
 * DynamicVariablesSchemaPatch is the request body for updating the project's dynamic variables.
 *
 */
export type DynamicVariablesSchemaPatch = {
    op: 'add' | 'remove' | 'replace';
    /**
     * The path to the field to update. This should be a JSON path to the field to update. For example, if you want
     * to update/remove the dynamic variables `newVar` in the following schema:
     *
     * ```
     * {
     * "type": "object",
     * "properties": {
     * "newVar": {
     * "type": "string"
     * }
     * }
     * }
     * ```
     *
     * The path would be `/properties/newVar`.
     *
     */
    path: string;
    /**
     * The value to set the field to. This should be valid JSON schema containing the name of the variable, its type
     * and any other properties. An example would be `{"newVar": {"type": "string"}}`.
     *
     */
    value?: {
        [key: string]: unknown;
    };
};

export type op = 'add' | 'remove' | 'replace';

/**
 * The Project represents a deployable unit within our platform that includes both the functional components (files) and configuration. It serves as the backbone of custom or predefined functionalities, allowing organizations to create, update, and manage APIs and projects.
 *
 */
export type Project = {
    /**
     * The unique identifier for the project.
     */
    id: string;
    /**
     * List of environments for the project.
     *
     */
    environments: Array<ProjectEnvironment>;
    name: string;
    currentFiles: Files;
    createdAt: string;
    dynamicVariablesSchema?: DynamicVariablesSchema;
};

export type ProjectEnvironment = {
    /**
     * The unique identifier for the environment.
     */
    id: string;
    name: string;
    /**
     * One of running|suspended|error|draft.
     */
    status: string;
    createdAt: string;
    updatedAt: string;
    publicUrl: string;
    /**
     * The files associated with the project.
     */
    files?: Array<File>;
    labels?: Labels;
};

export type File = {
    /**
     * The name of the file.
     */
    filename: string;
    /**
     * The content of the file.
     */
    content: string;
};

export type Files = {
    /**
     * The files associated with the project.
     */
    files: Array<File>;
    /**
     * The labels associated with the project. Labels are stored as key-value pairs.
     * Only string-string values are allowed
     *
     */
    labels: {
        [key: string]: unknown;
    };
};

/**
 * ErrorField denotes a field which has an error.
 */
export type ErrorField = {
    /**
     * Field is the name of the field which has an error, this may be a path to a nested field, including array
     * elements. The format of this field is of the form: "field1.field2[0].field3"
     *
     */
    field: string;
    /**
     * Message is the error message for this specific field.
     */
    message: string;
};

export type Error = {
    /**
     * Code is a machine-readable error code.
     */
    code: string;
    /**
     * Message is a human-readable error message.
     */
    message: string;
    fields?: Array<ErrorField>;
    details?: string;
};

export type Log = {
    timestamp: string;
    severity: string;
    message: string;
    error?: string;
    httpRequest?: {
        [key: string]: unknown;
    };
    fields?: {
        [key: string]: unknown;
    };
};

export type Logs = {
    logs: Array<Log>;
    nextToken?: string;
};

export type PageInfo = {
    totalCount: number;
    next?: string;
    prev?: string;
};

/**
 * This is the ID of the template that the connection is created against.
 *
 */
export type TemplateID = string;

/**
 * ConnectionUpdate is the request payload to update an existing connection.
 *
 */
export type ConnectionUpdate = {
    /**
     * Name is the name of the Connection. This must be unique within the owning Connector.
     */
    name: string;
    credentials: ConnectionCredentials;
    /**
     * The baseUrl on the connection allows a dynamic user to override the base URL of the connection. This is useful
     * when users have their own instance of a service and want to connect to it.
     *
     * For example, a user may have their own instance of shopify and their url is `https://myshopify.com`. They can
     * override the base url of the connection to `https://myshopify.com` and all requests will be made to this url.
     * If it is left as an empty string, it will be ignored.
     *
     */
    baseUrl: string;
};

/**
 * Connection defines the credentials for the owning Connector, and additional variables
 * which can be used to customize the Connector in a particular connection.
 *
 */
export type Connection = {
    /**
     * ID is the unique identifier of the Connection. Typically this is only used internally and most (if not all)
     * public-facing APIs will use the `name` in combination with the Connector's `id` instead.
     *
     */
    id: string;
    /**
     * Name is the name of the Connection. This must be unique within the owning Connector.
     */
    name: string;
    credentials: ConnectionCredentials;
    variables: Array<ConnectionVariable>;
    /**
     * The baseUrl on the connection allows a dynamic user to override the base URL of the connection. This is useful
     * when users have their own instance of a service and want to connect to it.
     *
     * For example, a user may have their own instance of shopify and their url is `https://myshopify.com`. They can
     * override the base url of the connection to `https://myshopify.com` and all requests will be made to this url.
     * If it is left as an empty string, it will be ignored.
     *
     */
    baseUrl?: string;
    /**
     * CreatedAt is the time the Connection was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time the Connection was last updated.
     */
    updatedAt: string;
    /**
     * ID of the system to add the project environment.
     */
    systemId?: string;
    connectionTemplateId?: TemplateID;
};

/**
 * ConnectionVariable denotes an arbitrary key/value pair which can be used to configure a connector.
 */
export type ConnectionVariable = {
    /**
     * Name is the name of the connection variable.
     */
    name: string;
    /**
     * Value is the value of the connection variable.
     */
    value: string;
};

/**
 * ConnectionCredentials defines the credentials for the owning Connector. If multiple
 * credentials are defined for each type, they are applied to the request in the order they are defined. This is to
 * enable Connectors which require both a user session token and an API key to be provided in the request.
 *
 */
export type ConnectionCredentials = Array<ConnectionCredential>;

/**
 * ConnectionPage defines a page of Connection summaries.
 */
export type ConnectionPage = PageInfo & {
    items: Array<Connection>;
};

/**
 * ConnectionCredential contains the a Credential and the AuthSchemeConfig to define how the Credential should be used against the Connection's Connector.
 */
export type ConnectionCredential = {
    id: string;
    authSchemeConfig?: AuthSchemeConfig;
    credential?: Credential;
};

/**
 * CredentialBase is the base type for all credentials. It contains the common properties which are shared across
 * all credential types.
 *
 */
export type Credential = {
    /**
     * ID is the unique identifier of the Credential.
     */
    id: string;
    /**
     * OrganisationID is the unique identifier of the Organisation which owns the Credential.
     */
    organisationId: string;
    type?: CredentialType;
    /**
     * Name is the name of the Credential.
     */
    name?: string;
    /**
     * Errors is a list of errors which occurred when attempting to validate the credential. This field may be
     * undefined, which implies that validation has not occurred and the consumer cannot assume whether this
     * Credential is valid or not. An empty array indicates that the Credential is valid.
     *
     */
    errors?: Array<(string)>;
    data?: CredentialData;
    /**
     * ExpiresAt denotes the time this credential should be automatically deleted. External systems can subscribe
     * to deletion events and if the reason is "expired", can trigger the correct notifications to interested
     * parties (such as un-publishing jobs which rely on the credential and emailing the owner to rectify it).
     *
     */
    expiresAt?: string;
};

export type CredentialData = {
    binary?: CredentialDataBinary;
    none?: CredentialDataNone;
    string?: CredentialDataString;
    basicAuth?: CredentialDataBasicAuth;
    oauth2Client?: CredentialDataOAuth2Client;
    oauth2Token?: CredentialDataOAuth2Token;
    oauth2Code?: CredentialDataOAuth2Code;
    oauth2Password?: CredentialDataOAuth2Password;
    certificate?: CredentialDataCertificate;
    oauth1?: CredentialDataOAuth1;
};

/**
 * CredentialType denotes the type of the credential which determines what the Credential's `data` property will
 * contain.
 *
 * - none: No credential is required to authenticate with the Connector.
 * - string: The credential is a string value, such as an API key or password.
 * - binary: The credential is a binary value, such as a private key, certificate or other file.
 * - basic-auth: The credential is a username and password to be used for basic authentication.
 * - oauth2-client: The credential is an OAuth2 client ID and secret to be used for OAuth2 authentication.
 * - oauth2-code: The credential is a temporary authorization code which will be exchanged for an oauth2-token.
 * - oauth2-password: The credential is an OAuth2 username and password with an optional client ID and secret to be used for OAuth2 authentication.
 * - oauth2-token: The credential is an OAuth2 access_token to be used for OAuth2 authentication.
 * - oauth1: The credential is an OAuth1 access_token to be used for OAuth1 authentication.
 * - certificate: The credential is a PEM encoded certificate, key and CA to be used for TLS client authentication.
 *
 */
export type CredentialType = 'none' | 'string' | 'binary' | 'basic-auth' | 'oauth2-client' | 'oauth1' | 'oauth2-code' | 'oauth2-password' | 'oauth2-token' | 'certificate';

/**
 * CredentialDataNone contains no data as no credential is required to authenticate with the Connector. It is used
 * purely as a placeholder to implement a consistent interface across all CredentialType/AuthSchemeTypes.
 *
 */
export type CredentialDataNone = {
    [key: string]: unknown;
};

/**
 * CredentialDataString contains a string value and nothing else and is commonly used for API keys. This value
 * will be redacted when returned in a response.
 *
 */
export type CredentialDataString = {
    /**
     * Value is a UTF-8 string containing the credential data. When read from the API this field will be redacted.
     *
     */
    value: string;
};

/**
 * CredentialJWTBearer contains the username and password required to authenticate with the Connector. The
 * `secret` property will be redacted when returned in a response.
 *
 */
export type CredentialJWTBearer = {
    algorithm: 'HS256' | 'HS384' | 'HS512' | 'RS256' | 'RS384' | 'RS512';
    /**
     * Secret is the base64 encoded secret used to sign new JWTs.
     *
     */
    secret: string;
    /**
     * Payload is stringified JSON object containing the default set of claims to include in the JWT payload.
     * Issued JWTs may contain additional claims and may overwrite ones defined here, such as `exp` and `iat`.
     *
     */
    payload: string;
    /**
     * Expires in is a duration in the form `1h2m3s` (see Go's `time.Duration` documentation) which defined
     * how long a newly issued JWT should be valid for.
     *
     */
    expiresIn: string;
    /**
     * AuthorizationHeaderPrefix is the prefix to use when setting the Authorization header, for example,
     * "Bearer" or "JWT".
     *
     */
    authorizationHeaderPrefix: string;
};

export type algorithm = 'HS256' | 'HS384' | 'HS512' | 'RS256' | 'RS384' | 'RS512';

/**
 * CredentialDataBasicAuth contains the username and password required to authenticate with the Connector. The
 * `password` property will be redacted when returned in a response.
 *
 */
export type CredentialDataBasicAuth = {
    /**
     * Username is the username used to authenticate with the Connector.
     */
    username: string;
    /**
     * Password is the password used to authenticate with the Connector. Will be redacted when returned in a
     * response.
     *
     */
    password: string;
};

/**
 * CredentialDataCertificate contains the Certificate, Certificate key and CA(Certificate authority).
 *
 */
export type CredentialDataCertificate = {
    /**
     * Certificate is the certificate that will be send to the connection.
     */
    certificate: string;
    /**
     * Key is the accompanying key for the certificate.
     */
    key: string;
    /**
     * CA is the Certificate Authority to verify the server certificates against.
     */
    ca: string;
};

/**
 * CredentialDataOAuth2Password contains the username and password of a Resource Owner within an OAuth 2.0
 * application. The `password` property will be redacted when returned in a response.
 *
 */
export type CredentialDataOAuth2Password = {
    /**
     * Username is the username used to authenticate with the Connector.
     */
    username: string;
    /**
     * Password is the password used to authenticate with the Connector. Will be redacted when returned in a
     * response.
     *
     */
    password: string;
};

/**
 * CredentialDataOAuth2Client contains the OAuth2 client credentials required to either issue an access token from
 * a refresh_token, or via the `client_credentials` and `authorization_code` grant types. The `clientSecret` property will be redacted when
 * returned in a response.
 *
 */
export type CredentialDataOAuth2Client = {
    /**
     * ClientID is the OAuth2 client ID used to authenticate with the Connector.
     *
     */
    clientId: string;
    /**
     * ClientSecret is the OAuth2 client secret used to authenticate with the Connector. Will be redacted when
     * returned in a response.
     *
     */
    clientSecret: string;
    /**
     * TokenURL is the URL which the application will use to issue an access token.
     */
    tokenUrl: string;
    /**
     * Scopes is a list of scopes which should be requested when issuing an access token. This is only required if
     * this credential is being used on a `client_credentials` grant type, for `authorization_code` grant types the
     * requested scopes come from the `CredentialDataOAuth2Token` credential.
     *
     */
    scopes?: Array<(string)>;
    /**
     * AdditionalParams is a URL-encoded query string which can be used to pass additional
     * parameters to the OAuth 2.0 token endpoint. These parameters are attached to the body
     * in the formatted as the `application/x-www-form-urlencoded` content-type.
     *
     */
    additionalParams?: string;
    /**
     * MTLSEnabled is a boolean flag which determines whether the client should use mutual TLS authentication when
     * communicating with the OAuth2 provider. If enabled, the `mTLSCredentialId` field must be set, or it must be
     * created via the `CreateConnection` endpoint with an associated mTLS credential defined beforehand, in which
     * case the mTLSCredentialID field will be populated upon saving by the API.
     *
     */
    mTLSEnabled?: boolean;
    /**
     * MTLSCredentialID is an optional reference to another credential being created.
     * If set the certificate credential will be used when making a request to the tokenUrl.
     *
     */
    mTLSCredentialId?: string;
};

/**
 * CredentialDataOAuth2Token is primarily used to store the refresh_token for an user who has authorized an OAuth2
 * Application to access their data. However, this information is not exposed publicly and the only data visible
 * via the API are the `scopes` which the user has granted consent for. This can be used to determine whether
 * the user should be prompted to re-authorize the application with additional scopes in the event they choose to
 * use a new endpoint which requires additional scopes to what they've already consented to.
 *
 */
export type CredentialDataOAuth2Token = {
    /**
     * Scopes is a list of scopes which the user has granted consent for.
     */
    scopes: Array<(string)>;
    /**
     * AccessToken is the OAuth2 access token which can be used to authenticate with the Connector. This
     * information is redacted when read from the API.
     *
     */
    accessToken?: string;
    /**
     * TokenType is the type of token which is being issued. Defaults to "Bearer" if not set.
     *
     */
    tokenType?: string;
    /**
     * ExpiresAt is the time at which the access token will expire. If not defined, the accessToken will be
     * reused until a 401 response is received from the Connector, at which point the token should be refreshed
     * with the provided `refreshToken`. Ideally this should be provided so that erroneous failures can be
     * avoided.
     *
     */
    expiresAt?: string;
    /**
     * RefreshToken is the OAuth2 refresh token which can be used to issue new access tokens. This information is
     * redacted when read from the API.
     *
     * This is a required field as it is used to refresh the access token when it expires. If users are providing
     * an access token which does not expire using this credential type, then the same functionality may be
     * achieved by using a simple API key and OAuth 2.0 need not be used.
     *
     */
    refreshToken: string;
};

/**
 * CredentialDataOAuth2Code is used to exchange an authorization code for an access token and
 * is denoted by the `oauth2-code` type.
 * This is only used when creating or updating an OAuth 2.0 connection using the
 * `authorization_code` grant type. Retrieving this credential will return a payload of
 * type `oauth2-token` in the shape of a `CredentialDataOAuth2Token` object.
 *
 */
export type CredentialDataOAuth2Code = {
    /**
     * Code is the authorization code which will be exchanged for an access token.
     *
     */
    code: string;
    /**
     * State is the state value which is propagated through the OAuth2 flow.
     *
     */
    state: string;
};

export type CredentialDataOAuth1 = {
    state: string;
    oauthToken: string;
    oauthVerifier: string;
};

/**
 * CredentialDataBinary is commonly used to store non-string data such as binary files or encryption keys. This
 * value will be redacted when returned in a response.
 *
 */
export type CredentialDataBinary = {
    /**
     * Value is a base64 encoded string containing the credential data. This could decode to a valid utf-8 string,
     * or it could decode to a binary file such as a private key etc. When read from the API this field will be
     * redacted.
     *
     */
    valueBase64: string;
};

export type AuthSchemeConfig = {
    type: AuthSchemeType;
    none?: AuthSchemeConfigNone;
    apiKey?: AuthSchemeConfigAPIKey;
    basicAuth?: AuthSchemeConfigBasicAuth;
    oauth2?: AuthSchemeConfigOAuth2;
    oauth1?: AuthSchemeConfigOAuth1;
    hmac?: AuthSchemeConfigHMAC;
    certificate?: AuthSchemeConfigCertificate;
};

/**
 * AuthSchemeConfigAPIKey defines how a Connector uses an API key credential to authenticate with the system.
 *
 */
export type AuthSchemeConfigAPIKey = AuthSchemeConfigBase & {
    /**
     * Name is the query parameter/header/cookie name which will be used to send the API key.
     */
    name: string;
    in: AuthSchemeConfigAPIKeyIn;
};

/**
 * AuthSchemeConfigAPIKeyIn defines the location of the API key in the request.
 *
 */
export type AuthSchemeConfigAPIKeyIn = 'query' | 'header' | 'cookie';

/**
 * Type is a unique identifier of the AuthScheme, this is a kebab-case formatted string, see
 * enum values for possible options.
 *
 */
export type AuthSchemeType = 'none' | 'api-key' | 'basic-auth' | 'oauth2' | 'hmac' | 'jwt-bearer' | 'certificate' | 'oauth1';

/**
 * OAuth2Scope represents a single scope which can be requested by an OAuth2 application.
 *
 */
export type OAuth2Scope = {
    /**
     * Name is the name of the scope as determined by the application to which this Connector
     * is connecting to.
     *
     */
    name: string;
    /**
     * Description describes the scope in human-friendly terminology. This text may be
     * displayed to users via a help tooltip or similar.
     *
     */
    description?: string;
};

export type AuthSchemeConfigBase = {
    /**
     * ID is the unique identifier of the AuthSchemeConfig, this is generated by the client and
     * only requires to be unique amongst the elements of the array in which is it contained.
     *
     */
    id: string;
    /**
     * Description enables users to distinguish multiple configurations which use the same
     * schemeType.
     *
     */
    description: string;
    /**
     * ValidationMessages is a list of messages which are generated when the AuthSchemeConfig
     * is validated. This is typically used to provide feedback to the user when they are
     * creating or updating the AuthSchemeConfig.
     *
     * This field will be ignored if sent to the API.
     *
     */
    validationMessages?: Array<Message>;
};

export type AuthSchemeConfigOAuth2GrantType = 'authorizationCode' | 'clientCredentials' | 'password';

/**
 * AuthSchemeConfigOAuth2GrantAuthorizationCode contains grant-specific configuration for the
 * `authorization_code` grant type.
 *
 * How the API manages changes to this configuration is as follows:
 *
 * - CredentialID and OrganisationID are not set, a new credential is created containing the
 * sensitive information and the non-sensitive information is updated in the database.
 * - Otherwise, both the credential and the database are updated using JSON Merge Patch, with
 * undefined properties not being updated.
 * - Any other permutation will result in a 400 Bad Request.
 *
 */
export type AuthSchemeConfigOAuth2GrantAuthorizationCode = {
    /**
     * CredentialID is the unique identifier of the Credential which contains the client ID and
     * client secret to be used as part of the `password` flow.
     *
     */
    credentialId?: string;
    /**
     * OrganisationID is the unique identifier of the Organisation that owns the Credential.
     * This can be different to the Connector's OrganisationID since some may be imported from
     * Versori's public library.
     *
     */
    organisationId?: string;
    /**
     * ClientID is the OAuth 2.0 client's identifier. This is not a sensitive value and may be
     * presented to the user in plaintext.
     *
     */
    clientId?: string;
    /**
     * ClientSecret is the OAuth 2.0 client's secret. This is a sensitive value and will not be
     * displayed to the user.
     *
     */
    clientSecret?: string;
};

export type AuthSchemeConfigOAuth2GrantClientCredentials = {
    [key: string]: unknown;
};

/**
 * AuthSchemeConfigOAuth2GrantPassword contains grant-specific configuration for the `password`
 * grant type.
 *
 * How the API manages changes to this configuration is as follows:
 *
 * - CredentialID and OrganisationID are not set, a new credential is created containing the
 * sensitive information and the non-sensitive information is created/updated in the
 * database.
 * - Otherwise, both the credential and the database are updated using JSON Merge Patch.
 * - Any other permutation will result in a 400 Bad Request.
 *
 */
export type AuthSchemeConfigOAuth2GrantPassword = {
    /**
     * CredentialID is the unique identifier of the Credential which contains the client ID and
     * client secret to be used as part of the `password` flow.
     *
     */
    credentialId?: string;
    /**
     * OrganisationID is the unique identifier of the Organisation that owns the Credential. This can be different
     * to the Connector's OrganisationID since some may be imported from Versori's public library.
     *
     */
    organisationId?: string;
    /**
     * ClientID is the OAuth 2.0 client's identifier. This is not a sensitive value and may be presented to the
     * user in plaintext.
     *
     */
    clientId?: string;
    /**
     * ClientSecret is the OAuth 2.0 client's secret. This is a sensitive value and will not be displayed to the
     * user. It may be populated when updating the Credential.
     *
     */
    clientSecret?: string;
};

export type AuthSchemeConfigOAuth2Grant = {
    authorizationCode?: AuthSchemeConfigOAuth2GrantAuthorizationCode;
    clientCredentials?: AuthSchemeConfigOAuth2GrantClientCredentials;
    password?: AuthSchemeConfigOAuth2GrantPassword;
    type: AuthSchemeConfigOAuth2GrantType;
};

/**
 * AuthSchemeConfigNone is a placeholder object with the schemeType set to `none`. There is no other configuration
 * required.
 *
 */
export type AuthSchemeConfigNone = AuthSchemeConfigBase;

/**
 * AuthSchemeConfigBasicAuth is a placeholder object with the schemeType set to `basic-auth`. There is no other
 * configuration required.
 *
 */
export type AuthSchemeConfigBasicAuth = AuthSchemeConfigBase;

/**
 * AuthSchemeConfigCertificate is a placeholder object with the schemeType set to `certificate`.
 * There is no other config required
 *
 */
export type AuthSchemeConfigCertificate = AuthSchemeConfigBase;

/**
 * AuthSchemeConfigOAuth2 defines how a Connector uses an OAuth2 credential to authenticate
 * with the system. This is to be used for all OAuth 2.0 flows which require a client ID and
 * client secret as part of the Connector's configuration. Connectors which use the
 * `client_credentials` grant type, where the user provides the Client ID  and Client Secret at
 * the point where they connect, should use the `AuthSchemeConfigOAuth2ClientCredentials` type
 * instead.
 *
 */
export type AuthSchemeConfigOAuth2 = AuthSchemeConfigBase & {
    /**
     * AuthorizeURL is the URL which the user will be redirected to in order to authorize
     * the application.
     *
     */
    authorizeUrl?: string;
    /**
     * TokenURL is the URL which the application will use to issue an access token.
     *
     */
    tokenUrl: string;
    /**
     * Scopes is the list of all OAuth2 scopes which the application supports. The user
     * will be allowed to choose which scopes to request when configuring the Connection.
     *
     */
    scopes: Array<OAuth2Scope>;
    /**
     * DefaultScopes is the list of scopes which will be requested by default when the user
     * connects the Connector. This is useful for Connectors which require a specific set
     * of scopes to function correctly.
     *
     */
    defaultScopes: Array<(string)>;
    /**
     * AdditionalAuthorizeParams is a URL-encoded query string which should be attached to
     * the AuthorizeURL when the user is redirected to the OAuth 2.0 authorization
     * endpoint.
     *
     * This value is only used by the UI to drive the default values when connecting, the
     * API to `InitialiseOAuth2Connection` can be provided a different value if required.
     *
     */
    additionalAuthorizeParams?: string;
    /**
     * AdditionalTokenParams is a URL-encoded string following the
     * `application/x-www-form-urlencoded` mime-type, which can be used to pass additional
     * parameters to the OAuth 2.0 token endpoint within the request body.
     *
     */
    additionalTokenParams?: string;
    /**
     * MTLSEnabled is a flag which determines whether the Connector should use Mutual TLS
     * (mTLS) to authenticate with the OAuth 2.0 token endpoint. This is useful for
     * Connectors which require a higher level of security.
     *
     */
    mtlsEnabled?: boolean;
    /**
     * MTLSCredentialID is the unique identifier of the Credential which contains the
     * client certificate and private key to be used as part of the mTLS connection.
     *
     * This may be unset when creating a connection, in which case if `mtlsEnabled` is
     * true, then the API will find an associated AuthSchemeConfigCertificate and link
     * them automatically.
     *
     */
    mtlsCredentialId?: string;
    grant: AuthSchemeConfigOAuth2Grant;
};

export type AuthSchemeConfigOAuth1 = AuthSchemeConfigBase & {
    consumerKey: string;
    consumerSecret: string;
    tempCredentialEndpoint: Endpoint;
    resourceOwnerAuthorizationEndpoint: Endpoint;
    tokenEndpoint: Endpoint;
    signatureMethod: string;
    credentialId?: string;
};

export type Endpoint = {
    /**
     * URL of the endpoint, may contain templated values in curly braces
     */
    url: string;
    additionalParamConfigs?: Array<ParameterConfig>;
    parameterTransmission?: 'AUTH_STYLE_AUTHORIZATION_HEADER' | 'AUTH_STYLE_FORM' | 'AUTH_STYLE_QUERY';
};

export type parameterTransmission = 'AUTH_STYLE_AUTHORIZATION_HEADER' | 'AUTH_STYLE_FORM' | 'AUTH_STYLE_QUERY';

export type ParameterConfig = {
    /**
     * Key of the additional parameter to insert
     */
    parameterName: string;
    /**
     * Override name for the parameter in endpoint requests
     */
    targetName?: string;
    location: 'LOCATION_IGNORE' | 'LOCATION_BODY' | 'LOCATION_HEADER' | 'LOCATION_QUERY' | 'LOCATION_ENDPOINT' | 'LOCATION_HEADER_PARAMETER';
    usages?: 'USAGE_UNKNOWN' | 'USAGE_TEMP_CREDENTIAL_ENDPOINT' | 'USAGE_TOKEN_REQUEST_ENDPOINT';
    /**
     * Whether parameter is required in requests
     */
    required: boolean;
    /**
     * Whether parameter can be modified by user
     */
    modifiable: boolean;
};

export type location = 'LOCATION_IGNORE' | 'LOCATION_BODY' | 'LOCATION_HEADER' | 'LOCATION_QUERY' | 'LOCATION_ENDPOINT' | 'LOCATION_HEADER_PARAMETER';

export type usages = 'USAGE_UNKNOWN' | 'USAGE_TEMP_CREDENTIAL_ENDPOINT' | 'USAGE_TOKEN_REQUEST_ENDPOINT';

/**
 * AuthSchemeConfigHMACIn defines where the signature should be set on requests.
 */
export type AuthSchemeConfigHMACIn = 'query' | 'header' | 'cookie';

/**
 * AuthSchemeConfigHMAC defines how a Connector uses an HMAC credential to authenticate with the system.
 *
 * This may be used on outbound requests to sign the request body, however it is more commonly used on inbound
 * requests (i.e. from Webhook Triggers) to verify the sender of the request is allowed to invoke the Trigger.
 *
 */
export type AuthSchemeConfigHMAC = AuthSchemeConfigBase & {
    /**
     * Name is the query parameter/header/cookie name which will be used to send the signature.
     */
    name: string;
    in: AuthSchemeConfigHMACIn;
    /**
     * AuthSchemeConfigHMACAlgorithm defines the hashing algorithm to use when generating the HMAC signature.
     */
    algorithm: 'sha1' | 'sha256' | 'sha512';
    /**
     * AuthSchemeConfigHMACInputs defines what parts of a HTTP request are consumed to generate the HMAC signature. Some systems
     * only generate the signature from the request body, others may include the URL. The order of this array
     * defines the order in which the input is fed into the hashing function.
     *
     */
    digestInputs: Array<('body' | 'url')>;
};

/**
 * AuthSchemeConfigHMACAlgorithm defines the hashing algorithm to use when generating the HMAC signature.
 */
export type algorithm2 = 'sha1' | 'sha256' | 'sha512';

/**
 * Message is a message to be displayed to the user to indicate some information about the
 * preceding request.
 *
 */
export type Message = {
    /**
     * Text contains the text of the message.
     */
    text: string;
    severity: MessageSeverity;
    /**
     * Details contains additional information about the message. This is intended to be used
     * to provide more information about the message, such as a list of validation errors.
     *
     */
    detail?: Array<(string)>;
};

export type MessageSeverity = 'info' | 'warning' | 'error';

/**
 * InitialiseOAuth2ConnectionRequest is the payload to initialise an OAuth 2.0 connection.
 *
 */
export type InitialiseOAuth2ConnectionRequest = {
    credential: {
        /**
         * ID is the unique identifier of the credential which is being used to
         * initialise the connection. This is used to load the client_secret when the authorisation
         * code is exchanged for an access token.
         *
         */
        id: string;
        /**
         * OrganisationID is the unique identifier of the organisation which the credential is
         * associated with. This is used to ensure that the credential is only used to initialise
         * connections for the organisation which owns the credential.
         *
         */
        organisationId: string;
    };
    /**
     * AuthorizeURL is the URL which the user will be redirected to in order to authorize
     * the application.
     *
     */
    authorizeUrl: string;
    /**
     * ClientID is the OAuth 2.0 client ID which is used to identify the application to the
     * OAuth 2.0 provider.
     *
     */
    clientId: string;
    /**
     * Scopes is a list of OAuth 2.0 scopes which the application is requesting access to.
     *
     * Unless `disableOfflineAccess` is set to true, the API will also include the standard
     * `offline_access` scope in addition to the ones provided here.
     *
     */
    scopes?: Array<(string)>;
    /**
     * DisableOfflineAccess is a flag which can be set to true to disable the inclusion of the
     * standard `offline_access` scope in the list of scopes. This is defined separately to
     * `scopes` to make it clear that the API will always include the `offline_access` scope
     * by default, but can be disabled if the system does not implement the standards so that
     * the user can define their own custom scope as part of `scopes`.
     *
     */
    disableOfflineAccess?: boolean;
    /**
     * Prompt controls the behaviour of the OAuth 2.0 provider when the user is redirected to
     * the authorize URL. This is typically used to force the user to re-authenticate or to
     * select a user account.
     *
     * If set, should be one of "none", "login", "consent", "select_account". However the
     * specification dictates that arbitrary prompts may be provided in case of new values
     * added in the future. Some providers also allow multiple values to be provided, separated
     * by the '+' symbol, i.e. `consent+select_account`.
     *
     * If not provided, this API defaults to "login", unless `additionalParams` contains the
     * `approval_prompt` parameter (thanks, Google refresh tokens), in which case this value
     * does not default to anything.
     *
     */
    prompt?: string;
    /**
     * AdditionalParams is a URL-encoded query string which can be used to pass additional
     * parameters to the OAuth 2.0 authorize endpoint. These cannot conflict with any of the
     * other parameters defined by the request, an attempt to do so will result in an error.
     *
     * These parameters are attached to returned URL as query parameters.
     *
     */
    additionalParams?: string;
};

/**
 * InitialiseOAuth2ConnectionResponse contains the URL to redirect the user to in order to
 * initiate an OAuth 2.0 `authorization_code` grant flow.
 *
 */
export type InitialiseOAuth2ConnectionResponse = {
    /**
     * The URL to redirect the user to.
     */
    url: string;
};

/**
 * InitialiseOAuth1ConnectionRequest is the payload to initialise an OAuth 1.0 connection.
 *
 */
export type InitialiseOAuth1ConnectionRequest = {
    credential: {
        id: string;
        organisationId: string;
    };
};

export type InitialiseOAuth1ConnectionResponse = {
    /**
     * The URL to redirect the user to.
     */
    url: string;
};

export type ConnectionCredentialsCreate = Array<ConnectionCredential>;

export type EndUser = {
    /**
     * ID is the Versori identifier for the user. Most APIs will not use this field but instead reference
     * users by their externalId.
     *
     */
    id: string;
    /**
     * ExternalID is the identifier for the user as determined by the organisation. This typically should
     * be the same as the user's ID on the organisations system. Regardless of the value, it must
     * be unique within the Organisation.
     *
     */
    externalId: string;
    /**
     * DisplayName is an optional human-readable name for the user. If not set, the default is an empty string.
     *
     */
    displayName: string;
    /**
     * The organisation ID to which the user belongs to.
     */
    organisationId: string;
    /**
     * CreatedAt is the time the user was created.
     */
    createdAt: string;
    /**
     * UpdatedAt is the time the user was last updated.
     */
    updatedAt: string;
};

/**
 * Request to create a new End User
 */
export type EndUserCreate = {
    /**
     * ExternalID is the identifier of the user
     */
    externalId: string;
    /**
     * DisplayName is a human-readable name for the user
     */
    displayName?: string;
};

export type EndUserPage = PageInfo & {
    users: Array<EndUser>;
};

export type Automation = {
    id: string;
    name: string;
    createdAt?: string;
};

export type AutomationRun = {
    prompt: string;
};

export type AutomationRunResponse = {
    executionId: string;
};

export type AutomationCreate = {
    name?: string;
};

export type UpdateSystem = {
    name?: string;
    domain?: string;
    templateBaseUrl?: string;
};

export type SystemCreate = {
    name: string;
    domain: string;
    templateBaseUrl: string;
    authSchemeConfigs: Array<AuthSchemeConfig>;
    labels?: Labels;
};

export type LinkSystem = {
    /**
     * ID of the system to add the project environment.
     */
    systemId: string;
    /**
     * How you will reference your system from the SDK.
     */
    name: string;
    /**
     * The environment to link the system to.
     */
    environmentId?: string;
    /**
     * If the connections to the system need to be dynamic or static.
     * Dynamic connections are used when the integration runs for multiple end users.
     * Defaults to false if not set.
     *
     */
    dynamic?: boolean;
};

export type System = {
    id: string;
    name: string;
    domain: string;
    authSchemeConfigs: Array<AuthSchemeConfig>;
    templateBaseUrl: string;
};

export type UpdateConnectionTemplate = {
    /**
     * The name of the template. This is how the connections should be referenced in code.
     */
    name?: string;
    dynamic?: boolean;
};

export type ConnectionTemplate = {
    /**
     * The system ID.
     */
    id: string;
    connectionTemplateId?: string;
    /**
     * The name of the template. This is how the connections should be referenced in code.
     */
    name: string;
    domain: string;
    dynamic: boolean;
    authSchemeConfigs: Array<AuthSchemeConfig>;
    templateBaseUrl: string;
};

/**
 * TriggerPage defines a paginated list of Triggers.
 */
export type EnvironmentSystemPage = PageInfo & {
    items: Array<ConnectionTemplate>;
    next?: string;
    prev?: string;
};

/**
 * TriggerPage defines a paginated list of Triggers.
 */
export type SystemPage = PageInfo & {
    items: Array<System>;
};

/**
 * Labels is a map of key-value pairs that can be used to store arbitrary metadata about a resource.
 * Keys must start with a letter and can only contain letters, numbers, and underscores.
 * Values can be any string.
 *
 */
export type Labels = {
    [key: string]: unknown;
};

export type DynamicVariables = {
    [key: string]: unknown;
};

export type Parameteruser_id = string;

export type Parameterorganisation_id = string;

export type Parameterconnection_id = string;

export type Parameterautomation_id = string;

export type Parameterenvironment_id = string;

export type Parameteractivation_id = string;

export type Parameterenv_system_id = string;

export type Parameterproject_id = string;

export type Parametersystem_id = string;

export type Parameterenv_id = string;

export type Parameterproject_env = string;

export type Parameterfirst = number;

export type Parameterbefore = string;

export type Parameterafter = string;

export type Parametersearch = string;

export type ActivateUserData = {
    body?: ActivationCreate;
    path: {
        organisation_id: string;
    };
};

export type ActivateUserResponse = (Activation);

export type ActivateUserError = unknown;

export type ListProjectsData = {
    path: {
        organisation_id: string;
    };
};

export type ListProjectsResponse = (ProjectsList);

export type ListProjectsError = (Error);

export type CreateProjectData = {
    body?: ProjectCreate;
    path: {
        organisation_id: string;
    };
};

export type CreateProjectResponse = (Project);

export type CreateProjectError = (Error);

export type GetProjectData = {
    path: {
        organisation_id: string;
        project_id: string;
    };
};

export type GetProjectResponse = (Project);

export type GetProjectError = (Error);

export type DeleteProjectData = {
    path: {
        organisation_id: string;
        project_id: string;
    };
};

export type DeleteProjectResponse = (void);

export type DeleteProjectError = (Error);

export type UpdateProjectData = {
    body: ProjectUpdate;
    path: {
        organisation_id: string;
        project_id: string;
    };
};

export type UpdateProjectResponse = (Project);

export type UpdateProjectError = (Error);

export type SetProjectVariablesSchemaData = {
    body: DynamicVariablesSchema;
    path: {
        organisation_id: string;
        project_id: string;
    };
};

export type SetProjectVariablesSchemaResponse = (DynamicVariablesSchema);

export type SetProjectVariablesSchemaError = (Error);

export type PatchProjectVariablesSchemaData = {
    body: DynamicVariablesSchemaPatch;
    path: {
        organisation_id: string;
        project_id: string;
    };
};

export type PatchProjectVariablesSchemaResponse = (DynamicVariablesSchema);

export type PatchProjectVariablesSchemaError = (Error);

export type GetFilesData = {
    path: {
        organisation_id: string;
        project_id: string;
    };
};

export type GetFilesResponse = (Files);

export type GetFilesError = (Error);

export type UpdateFilesData = {
    body: Files;
    path: {
        organisation_id: string;
        project_id: string;
    };
};

export type UpdateFilesResponse = (Files);

export type UpdateFilesError = (Error);

export type DeployProjectData = {
    body: Files;
    path: {
        organisation_id: string;
        project_id: string;
    };
    query?: {
        env_id?: string;
        project_env?: string;
    };
};

export type DeployProjectResponse = (Project);

export type DeployProjectError = (Error);

export type GetProjectLogsData = {
    path: {
        organisation_id: string;
        project_id: string;
    };
    query?: {
        build?: boolean;
        end?: string;
        latest?: boolean;
        next_token?: string;
        project_env?: string;
        start?: string;
    };
};

export type GetProjectLogsResponse = (Logs);

export type GetProjectLogsError = (Error);

export type SuspendProjectData = {
    path: {
        organisation_id: string;
        project_id: string;
    };
    query: {
        environment: string;
    };
};

export type SuspendProjectResponse = (Project);

export type SuspendProjectError = (Error);

export type ListConnectionsData = {
    path: {
        organisation_id: string;
    };
    query?: {
        after?: string;
        before?: string;
        end_user_id?: string;
        first?: number;
        system_id?: string;
    };
};

export type ListConnectionsResponse = (ConnectionPage);

export type ListConnectionsError = (Error);

export type CreateConnectionData = {
    body?: EnvSystemConnectionCreate;
    path: {
        organisation_id: string;
    };
};

export type CreateConnectionResponse = (Connection);

export type CreateConnectionError = (Error);

export type GetConnectionData = {
    path: {
        connection_id: string;
        organisation_id: string;
    };
};

export type GetConnectionResponse = (Connection);

export type GetConnectionError = (Error);

export type UpdateConnectionData = {
    body: ConnectionUpdate;
    path: {
        connection_id: string;
        organisation_id: string;
    };
};

export type UpdateConnectionResponse = (Connection);

export type UpdateConnectionError = (Error);

export type LinkConnectionToEnvironmentData = {
    body?: LinkConnectionEnvironment;
    path: {
        connection_id: string;
        organisation_id: string;
    };
};

export type LinkConnectionToEnvironmentResponse = (unknown);

export type LinkConnectionToEnvironmentError = (Error);

export type CreateEndUserData = {
    body?: EndUserCreate;
    path: {
        organisation_id: string;
    };
};

export type CreateEndUserResponse = (EndUser);

export type CreateEndUserError = (Error);

export type ListEndUsersData = {
    path: {
        organisation_id: string;
    };
    query?: {
        /**
         * Filter users by their activation status. Must be used together with environment_id.
         * If not provided, returns all users regardless of activation status.
         *
         */
        activated?: boolean;
        /**
         * Filter users by activations in a specific environment. Must be used together with the 'activated' parameter.
         * When combined with 'activated=true', it returns users that are activated in the specified environment.
         * When combined with 'activated=false', it returns users that are not activated in this specific environment.
         * If not provided, returns users from all environments.
         *
         */
        environment_id?: string;
        /**
         * Search is a string that is used to filter the list of End Users. The search string is matched against the
         * id, externalId and displayName fields.
         *
         */
        search?: string;
    };
};

export type ListEndUsersResponse = (EndUserPage);

export type ListEndUsersError = (Error);

export type ListAutomationsData = {
    path: {
        organisation_id: string;
    };
};

export type ListAutomationsResponse = (Array<Automation>);

export type ListAutomationsError = (Error);

export type CreateAutomationData = {
    body?: AutomationCreate;
    path: {
        organisation_id: string;
    };
};

export type CreateAutomationResponse = (Automation);

export type CreateAutomationError = (Error);

export type RunAutomationData = {
    body?: AutomationRun;
    path: {
        automation_id: string;
        organisation_id: string;
    };
};

export type RunAutomationResponse = (AutomationRunResponse);

export type RunAutomationError = unknown;

export type GetAutomationData = {
    path: {
        automation_id: string;
        organisation_id: string;
    };
};

export type GetAutomationResponse = (Automation);

export type GetAutomationError = (Error);

export type ListActivationsData = {
    path: {
        environment_id: string;
        organisation_id: string;
    };
};

export type ListActivationsResponse = (Activation);

export type ListActivationsError = (Error);

export type GetActivationData = {
    path: {
        activation_id: string;
        environment_id: string;
        organisation_id: string;
    };
};

export type GetActivationResponse = (Activation);

export type GetActivationError = (Error);

export type DeleteActivationData = {
    path: {
        activation_id: string;
        environment_id: string;
        organisation_id: string;
    };
};

export type DeleteActivationResponse = (void);

export type DeleteActivationError = (Error);

export type SetDynamicVariableData = {
    body: {
        /**
         * The new value for the variable (can be any JSON type)
         */
        value: {
            [key: string]: unknown;
        };
    };
    path: {
        activation_id: string;
        environment_id: string;
        organisation_id: string;
        /**
         * The name of the dynamic variable to update
         */
        variable_name: string;
    };
};

export type SetDynamicVariableResponse = (DynamicVariables);

export type SetDynamicVariableError = (Error);

export type ListUserActivationsData = {
    path: {
        environment_id: string;
        /**
         * The external ID of the user
         */
        external_user_id: string;
        organisation_id: string;
    };
};

export type ListUserActivationsResponse = (Array<Activation>);

export type ListUserActivationsError = (Error);

export type GetEndUserData = {
    path: {
        organisation_id: string;
        /**
         * The ID of the user
         */
        user_id: string;
    };
};

export type GetEndUserResponse = (EndUser);

export type GetEndUserError = (Error);

export type DeleteEndUserData = {
    path: {
        organisation_id: string;
        /**
         * The ID of the user
         */
        user_id: string;
    };
};

export type DeleteEndUserResponse = (void);

export type DeleteEndUserError = (Error);

export type GetActivationConnectionData = {
    path: {
        activation_id: string;
        env_system_id: string;
        organisation_id: string;
    };
};

export type GetActivationConnectionResponse = (Connection);

export type GetActivationConnectionError = unknown;

export type CreateSystemData = {
    body?: SystemCreate;
    path: {
        organisation_id: string;
    };
};

export type CreateSystemResponse = (System);

export type CreateSystemError = (Error);

export type ListSystemsData = {
    path: {
        organisation_id: string;
    };
    query?: {
        after?: string;
        before?: string;
        first?: number;
        search?: string;
    };
};

export type ListSystemsResponse = (SystemPage);

export type ListSystemsError = unknown;

export type UpdateSystemData = {
    body?: UpdateSystem;
    path: {
        organisation_id: string;
        system_id: string;
    };
};

export type UpdateSystemResponse = (System);

export type UpdateSystemError = (Error);

export type DeleteAuthSchemeConfigData = {
    path: {
        auth_scheme_config_id: string;
        organisation_id: string;
        system_id: string;
    };
};

export type DeleteAuthSchemeConfigResponse = (void);

export type DeleteAuthSchemeConfigError = (Error);

export type UpsertAuthSchemeConfigData = {
    body?: AuthSchemeConfig;
    path: {
        auth_scheme_config_id: string;
        organisation_id: string;
        system_id: string;
    };
};

export type UpsertAuthSchemeConfigResponse = (AuthSchemeConfig);

export type UpsertAuthSchemeConfigError = (Error);

export type ListEnvironmentConnectionsData = {
    path: {
        organisation_id: string;
        project_id: string;
    };
    query?: {
        env_id?: string;
    };
};

export type ListEnvironmentConnectionsResponse = (ConnectionPage);

export type ListEnvironmentConnectionsError = (Error);

export type LinkSystemData = {
    body?: LinkSystem;
    path: {
        organisation_id: string;
        project_id: string;
    };
};

export type LinkSystemResponse = (void);

export type LinkSystemError = (Error);

export type ListProjectSystemsData = {
    path: {
        organisation_id: string;
        project_id: string;
    };
    query?: {
        env_id?: string;
    };
};

export type ListProjectSystemsResponse = (EnvironmentSystemPage);

export type ListProjectSystemsError = unknown;

export type UnlinkSystemData = {
    body?: LinkSystem;
    path: {
        organisation_id: string;
        project_id: string;
    };
};

export type UnlinkSystemResponse = (void);

export type UnlinkSystemError = unknown;

export type CreateConnectionTemplateData = {
    body?: LinkSystem;
    path: {
        organisation_id: string;
        project_id: string;
    };
};

export type CreateConnectionTemplateResponse = (ConnectionTemplate);

export type CreateConnectionTemplateError = (Error);

export type ListProjectConnectionTemplatesData = {
    path: {
        organisation_id: string;
        project_id: string;
    };
    query?: {
        env_id?: string;
    };
};

export type ListProjectConnectionTemplatesResponse = (EnvironmentSystemPage);

export type ListProjectConnectionTemplatesError = unknown;

export type DeleteConnectionTemplateData = {
    path: {
        organisation_id: string;
        project_id: string;
        template_id: string;
    };
};

export type DeleteConnectionTemplateResponse = (void);

export type DeleteConnectionTemplateError = (Error);

export type UpdateConnectionTemplateData = {
    body?: UpdateConnectionTemplate;
    path: {
        organisation_id: string;
        project_id: string;
        template_id: string;
    };
};

export type UpdateConnectionTemplateResponse = (ConnectionTemplate);

export type UpdateConnectionTemplateError = (Error);

export type InitialiseOauth2ConnectionData = {
    body?: InitialiseOAuth2ConnectionRequest;
    path: {
        organisation_id: string;
        system_id: string;
    };
};

export type InitialiseOauth2ConnectionResponse = (InitialiseOAuth2ConnectionResponse);

export type InitialiseOauth2ConnectionError = (Error);