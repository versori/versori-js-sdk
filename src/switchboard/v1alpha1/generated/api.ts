/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/switchboard/organisations/{organisationId}/boards/{boardId}/variables": {
    /** @description Get the JSON schema for the variables of a board. */
    get: operations["GetBoardVariablesSchema"];
  };
  "/switchboard/organisations/{organisationId}/hubs/{hubId}/boards": {
    /** @description Retrieves the boards belonging to a given hub and organisation. */
    get: operations["ListHubBoards"];
  };
  "/switchboard/organisations/{organisationId}/hubs/{hubId}/users/{userId}": {
    /** @description Retrieves a pagniated list of boards belonging to a given user and hub. */
    get: operations["GetUserHubBoards"];
  };
  "/switchboard/organisations/{organisationId}/connected-apps": {
    /** @description Retrieves a page of Apps which have connections for an organisation. */
    get: operations["GetConnectedApps"];
  };
  "/switchboard/organisations/{organisationId}/connections": {
    /**
     * @description Retrieves connections for an organisation, potentially filtering by appId. The response is structured as a page
     * but currently the response returns all items. Consumers wishing to be backwards compatible should not assume
     * this API will always return all items.
     */
    get: operations["GetConnections"];
    /**
     * @description Creates a connection between an organisation and an App. This is to be used by authentication methods which the
     * user can explicitly configure, such as API Key and Basic Auth. For OAuth2/OIDC connections, users should call
     * the InitialiseConnection endpoint instead.
     */
    post: operations["CreateConnection"];
  };
  "/switchboard/organisations/{organisationId}/hubs/{hubId}/boards/{boardId}/integration-info": {
    /** @description Retrieves all the information needed that a user needs to fill out to use a Hub integration. */
    get: operations["IntegrationInfo"];
  };
  "/switchboard/organisations/{organisationId}/connection-init": {
    /**
     * @description InitialiseConnection is used to initiate a connection of an App to a user's organisation. Different connections
     * require different auth methods (or even no auth method at all), this endpoint returns the necessary
     * configuration required to establish that connection.
     */
    post: operations["InitialiseConnection"];
  };
  "/switchboard/organisations/{organisationId}/credentials": {
    /**
     * @description CreateCredential allows users to create new Credentials. Valid requests which return a credential marked as
     * "invalid" is normal behaviour, but the credential won't be usable until it's updated to become valid.
     */
    post: operations["CreateCredential"];
  };
  "/hubs-sdk/organisations/{orgId}/hubs/{hubId}/boards/{boardId}/users/{userId}": {
    /** @description Returns the user specified by the userId. */
    get: operations["GetUser"];
    /** @description Updates the given user. */
    put: operations["PutUser"];
    /** @description Create a new User. */
    post: operations["PostUser"];
    /** @description Delete a user. */
    delete: operations["DeleteUser"];
  };
  "/switchboard/connections/oauth2/callback": {
    /**
     * @description FinaliseConnectionCallback is the redirect URL to exchange an authorization code for an access token in an
     * OAuth2.0 authorization code grant. It must be noted that the real callback URL configured with the
     * OAuth2.0 provider should be a Switchboard URL (prompted to the user at app-creation time) and not this API URL.
     */
    get: operations["FinaliseConnectionCallback"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * @description Credential holds sensitive data not owned by Versori. Users can create credentials so that Versori systems can
     * authenticate to external services on behalf of the user.
     */
    Credential: {
      /** @description ID is the identifier for the credential. */
      id: string;
      /** @description OrganisationID is the ID of the organisation which owns this credential. */
      organisationID: unknown;
      /** @description Name is the credential name. */
      name: string;
      /** @description Data is a map of string keys to string base64 encoded values for the actual credential data. */
      data: Record<string, never>;
      type: components["schemas"]["CredentialType"];
      /**
       * @description RedactFields is a list of fields within data which once created should not be returned to the user. This
       * property is only applicable for "Default" credential types. Credentials of other types have their own
       * redaction list internally and this field will be ignored.
       */
      redactFields?: string[];
      /**
       * Format: date-time
       * @description ExpiresAt allows the user to specify when Switchboard should automatically delete the credential.
       */
      expiresAt?: string;
    };
    SchemaMetadata: {
      /**
       * @description Type denotes the type of schema the corresponding App is backed by. Currently the only supported value is
       * "openapi", but other types such as "soap", "graphql" and "grpc" are on the roadmap.
       */
      type: string;
      /**
       * @description Version denotes the version of the schema specification. This property is contextual based on the schema
       * type, for example openapi schemas will contain the OpenAPI specification version (currently only 3.0.x is
       * supported), but `grpc` APIs could be "proto2" or "proto3".
       */
      version: string;
      /**
       * @description URL is the private address for accessing the schema. This is not guaranteed to be publicly accessible and
       * could be a non-HTTP protocol (i.e. gs:// or s3://)
       */
      url: string;
    };
    Schema: {
      id: string;
      /**
       * @description Type denotes the type of schema the corresponding App is backed by. Currently the only supported value is
       * "openapi", but other types such as "soap", "graphql" and "grpc" are on the roadmap.
       */
      type: string;
      /**
       * @description Version denotes the version of the schema specification. This property is contextual based on the schema
       * type, for example openapi schemas will contain the OpenAPI specification version (currently only 3.0.x is
       * supported), but `grpc` APIs could be "proto2" or "proto3".
       */
      version: string;
      /**
       * @description URL is the private address for accessing the schema. This is not guaranteed to be publicly accessible and
       * could be a non-HTTP protocol (i.e. gs:// or s3://)
       */
      sourceUrl: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      deletedAt?: string;
    };
    ConnectIntegration: {
      connections?: components["schemas"]["HubApp"][];
      variables?: Record<string, never>;
    };
    HubApp: {
      id?: string;
      name?: string;
      imageUrl?: string;
      /**
       * @description ListenerUrl is the URL which webhooks will send data to Switchboard. This is only populated if the
       * app has a listener URL configured.
       */
      listenerUrl?: string;
      /**
       * @description RequiresUserAuth is true if the app requires the user of the integration to authenticate with the app before it can be used.
       * Apps that have this set to true, should be the only ones shown in the client's UI. The other apps are
       * only really returned due to the possiblity of them having a listener URL which the user may need to configure
       * webhooks with.
       */
      requiresUserAuth?: boolean;
      authConfig?: components["schemas"]["AppAuthConfig"][];
    };
    Users: {
      users?: string[];
    };
    User: {
      /**
       * @description The id of the user.
       * This needs to be provided when creating a user and must be unique for the board.
       * It must follow thw following regex \A[-/_=\.a-zA-Z0-9]+\z
       */
      id: string;
      environments?: components["schemas"]["Environments"][];
      variables?: {
        [key: string]: unknown;
      };
    };
    Environments: {
      /** @description Human identifier for the environment. Must be unique for the user. */
      key: string;
      credentialId: string;
      connectionId: string;
      /** @description The variables that will be used by the connection for this environment. */
      variables: Record<string, never>;
    };
    Error: {
      code: string;
      message: string;
      error: string;
    };
    App: {
      id: string;
      orgId: string;
      name: string;
      public: boolean;
      server: components["schemas"]["Server"];
      schemaMetadata: components["schemas"]["SchemaMetadata"];
      /**
       * @description SupportedAuthConfigs is a list of authentication standards which can be used to connect a user's account to
       * this app. At least one auth type needs to be valid for the App to be used by a user.
       */
      supportedAuthConfigs?: components["schemas"]["AppAuthConfig"][];
      imageUrl?: string;
      schema: components["schemas"]["Schema"];
      schemaId?: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      deletedAt?: string;
    };
    /** @description AppAuthConfig describes how an organisation can authenticate with an app. */
    AppAuthConfig: {
      /** @description Type denotes the method of authentication. Valid values are: `"oidc"`, `"oauth2"`, `"apikey"`, `"httpBasicAuth" */
      type: string;
      /**
       * @description IsValid is true if and only if the `data` field is populated with all the required information to enable
       * an organisation to connect to the App via this auth type. It is allowed for an App to have invalid auth
       * configs providing there is at least one valid.
       */
      isValid: boolean;
      data: components["schemas"]["AppAuthConfigData"];
    };
    /**
     * @description AppAuthConfigData should JSON-marshal to one of the types specified in the jsonschema oneOf:
     *
     * - AppAuthConfigOIDC
     * - AppAuthConfigOAuth2
     * - AppAuthConfigApiKey
     * - AppAuthConfigHTTPRefresh
     * - AppAuthConfigHTTPBasicAuth
     */
    AppAuthConfigData: components["schemas"]["AppAuthConfigOIDC"] | components["schemas"]["AppAuthConfigOAuth2"] | components["schemas"]["AppAuthConfigApiKey"] | components["schemas"]["AppAuthConfigHTTPRefresh"] | components["schemas"]["AppAuthConfigHTTPBasicAuth"];
    /** @description AppAuthConfigOIDC specifies the configuration for authenticating using the OpenID Connect specification. */
    AppAuthConfigOIDC: {
      /** @description Takes precedent over the endpoint properties. If this property is set, it will be queried and override any defined endpoint properties. */
      discoveryUrl?: string;
      clientId?: string;
      /**
       * @description ClientSecret is the OAuth2.0 client's secret. This should be write-only, and not be viewable after
       * creation.
       */
      clientSecret?: string;
      scopes?: components["schemas"]["Scopes"];
    };
    AppAuthConfigOAuth2: {
      /**
       * @description FlowType is the type of OAuth2 Flow supported. Valid values are `authorizationCode` and `clientCredentials`.
       *
       * @enum {string}
       */
      flowType?: "authorizationCode" | "clientCredentials";
      authorizationEndpoint?: string;
      tokenEndpoint?: string;
      clientId?: string;
      /**
       * @description ClientSecret is the OAuth2.0 client's secret. This should be write-only, and not be viewable after
       * creation.
       */
      clientSecret?: string;
      scopes?: components["schemas"]["Scopes"];
    };
    AppAuthConfigApiKey: {
      /** @description Name is the header, query param or cookie name which the API key should be provided as. */
      name: string;
      /**
       * @description In denotes where the API key should be set when calling the API. Possible values are: `"query"`,
       * `"header"` or `"cookie"`.
       */
      in: string;
    };
    AppAuthConfigHTTPBasicAuth: {
      /** @description User is the identifier to perform the basic authentication. */
      user: string;
      /** @description Password is the secret used to perform the basic authentication. */
      password: string;
    };
    AppAuthConfigHTTPRefresh: {
      /** @description TokenEndpoint is the URL to use to Request a token. */
      tokenEndpoint: string;
      /**
       * @description The http method to use for the token request.
       * @enum {string}
       */
      method: "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
      /** @description TokenTTL is the duration in seconds for a token to last before refreshing to get a new one. */
      tokenTTL: number;
      /** @description In denotes where the client secret should be set when calling the API. Possible values are: `"header"` or `"body"`. */
      in: string;
      /**
       * @description HeaderDestination is used if `"in"` is set to `"header"` to specify the header key for the ClientSecret data to be sent with.
       * This can be empty if the `"in"` is not set to `"header"`.
       */
      headerDestination?: string;
      /** @description Headers is a list of static headers to send along with the token request. */
      headers?: Record<string, never>;
      /**
       * @description Selector is an expression to evaluate to obtain the token from the Response returned from the TokenEndpoint.
       * This always extracts from the body response from the TokenEndpoint.
       */
      selector: string;
      /** @description TargetName is the header, query param or cookie name which the token should be provided as. */
      targetName?: string;
      /**
       * @description TargetIn denotes where the token should be set when calling the API. Possible values are: `"query"`,
       * `"header"` or `"cookie"`.
       */
      targetIn?: string;
    };
    /** @description AppAuthConfigCreate describes how an organisation can authenticate with an app. */
    AppAuthConfigCreate: {
      /** @description Type denotes the method of authentication. Valid values are: `"oidc"`, `"oauth2"` or `"apikey"`. */
      type: string;
      data: components["schemas"]["AppAuthConfigData"];
    };
    Hub: {
      id: string;
      orgId: string;
      name: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      deletedAt?: string;
    };
    HubBoardUsers: components["schemas"]["HubBoardUser"][];
    HubBoardUser: {
      userId: string;
      boardId: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      deletedAt?: string;
    };
    Board: {
      id: string;
      orgId: string;
      name: string;
      hubId?: string;
      status: components["schemas"]["BoardStatus"];
      activePublishInfo?: components["schemas"]["BoardPublishInfo"];
      /**
       * @description RecentPublishHistory is an array of BoardPublishInfo containing up to the last 5 publishes for a board. If
       * full history is required, users should use the ListPublishHistory operation for a paginated view.
       */
      recentPublishHistory?: components["schemas"]["BoardPublishInfo"][];
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      deletedAt?: string;
    };
    BoardCreate: {
      name: string;
      hubId?: string;
      nodes?: Record<string, never>;
      edges?: Record<string, never>;
    };
    HubBoardCreate: {
      name: string;
    };
    BoardPublishCommand: {
      lastEventId: string;
    };
    BoardUnpublishCommand: {
      taskId: string;
    };
    /**
     * @description BoardPublishResult is used to indicate if the publish request has been accepted. The actual scheduling is
     * done in the background and does not indicate the board is ready to accept data.
     */
    BoardPublishResult: {
      ok: boolean;
      taskId?: string;
    };
    /**
     * @description BoardUnpublishResult is used to indicate if the unpublish request has been accepted. The actual scheduling is
     * done in the background and does not indicate the board has terminated.
     */
    BoardUnpublishResult: {
      ok: boolean;
    };
    BoardPublishResultMessage: {
      /** @description One of, "info", "warn" or "error" */
      type: string;
      /** @description The main message to display to the user */
      message: string;
      /** @description An optional field containing further information relating to the message. */
      details?: string[];
    };
    /**
     * @description BoardStatus is used to indicate the status of a board. The "unknown" status is used in case of inconsistencies
     * in the database with the Board scheduler and the API cannot deduce the correct status without administrator
     * intervention.
     *
     * If the status is "unknown", then clients should assume it's in a draft/published state based on
     * whether the board has an "activePublishInfo" field. If a board cannot be published due to it already
     * being published and the "activePublishInfo" field is null, users should contact support.
     *
     * @enum {string}
     */
    BoardStatus: "unknown" | "draft" | "publishing" | "published" | "unpublishing";
    /** @description BoardPublishInfo provides information on a published board instance */
    BoardPublishInfo: {
      id: string;
      /**
       * @description TaskID is a unique identifier for the execution of a board. Each time a board is (re)published a new task ID
       * will be generated.
       */
      taskId: string;
      /**
       * @description LastEventID is the last observed event before this board was published. This may not be the last event on
       * the stream for this board, since the observer may not have replayed all events at the time of publish. As
       * such, the version of the board which will be executed is defined by this field, and not necessarily the
       * latest event on the stream.
       */
      lastEventId: string;
      listeners: components["schemas"]["BoardListener"][];
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      deletedAt?: string;
    };
    /** @description BoardListener provides information on where a board is listening for external events. */
    BoardListener: {
      id: string;
      /** @description AppNodeID is the identifier of the App Node to which this listener's operation belongs to. */
      appNodeId: string;
      /**
       * @description OperationNodeID is the identifier of the Operation within the App Node, which is listening for data from an
       * external source.
       */
      operationNodeId: string;
      /**
       * @description URL is the address for where the Node specified by NodeID is listening. Downstream services (such as
       * webhooks) should be configured with this URL.
       */
      url: string;
      /**
       * @description ContentType is the "content-type" header for which data should be sent with. Initially only
       * "application/json" is supported but other content types may be added in the future.
       */
      contentType: string;
      /**
       * @description Security defines any parameters which external services must supply in order for Switchboard to acknowledge
       * an incoming event. If this is defined but an external service does not supply matching information, the
       * event will be ignored.
       */
      security?: Record<string, never>;
      /** @description AdditionalHeaders describes any other headers which the downstream service must supply with the request. */
      additionalHeaders?: {
        [key: string]: string[];
      };
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      deletedAt?: string;
    };
    BoardsPage: components["schemas"]["PageInfo"] & {
      items?: components["schemas"]["Board"][];
    };
    HubsPage: components["schemas"]["PageInfo"] & {
      items?: components["schemas"]["Hub"][];
    };
    Connection: {
      id: string;
      orgId: string;
      name: string;
      app: components["schemas"]["App"];
      authConfig?: components["schemas"]["AppAuthConfig"];
      credentialId: string;
      usedByBoards?: components["schemas"]["ConnectionBoardReference"][];
    };
    /** @description Describes which boards a connection is in use by. */
    ConnectionBoardReference: {
      id?: string;
      name?: string;
    };
    /**
     * @description CreateConnectionRequestBody is the request body to create a new connection. The ID is automatically generated
     * and the organisation ID is defined by the request's path parameter.
     */
    CreateConnectionRequestBody: {
      name: string;
      appId: string;
      authType: string;
      data: components["schemas"]["ConnectionDataAPIKey"] | components["schemas"]["ConnectionDataHTTPBasicAuth"] | components["schemas"]["ConnectionDataSecret"] | components["schemas"]["ConnectionDataOAuth2ClientCredentials"];
    };
    /**
     * @description UpdateConnectionRequestBody is the request body to update an existing connection. This will replace the existing
     * connection details.
     */
    UpdateConnectionRequestBody: {
      name: string;
      data: components["schemas"]["ConnectionDataAPIKey"] | components["schemas"]["ConnectionDataHTTPBasicAuth"] | components["schemas"]["ConnectionDataSecret"] | components["schemas"]["ConnectionDataOAuth2ClientCredentials"];
    };
    /** @description ConnectionDataAPIKey is the data element of a connection which is using an apikey authentication type. */
    ConnectionDataAPIKey: {
      apiKey: string;
    };
    /** @description ConnectionDataHTTPBasicAuth is the data element of a connection which is using a HTTP Basic Auth authentication type. */
    ConnectionDataHTTPBasicAuth: {
      user: string;
      password: string;
    };
    /** @description ConnectionDataSecret is the data element of a connection for an authentication type requiring a secret (eg HTTPRefresh). */
    ConnectionDataSecret: {
      secret: string;
    };
    /** @description ConnectionDataOAuth2ClientCredentials is the data element of a connection for OAuth2 using the client_credentials flow. */
    ConnectionDataOAuth2ClientCredentials: {
      clientId: string;
      clientSecret: string;
      /**
       * @description AdditionalParameters is a URL-encoded query string which can be used to be pass extra parameters the OAuth2
       * provider.
       *
       * @example audience=https://example.com
       */
      additionalParameters?: string;
      /**
       * @description IssueToken is a flag which indicates whether the connection should issue a token when it is created. The
       * request to create/update a connection will fail if this is true and issuing fails.
       *
       * @default false
       */
      issueToken?: boolean;
    };
    ConnectedAppsPage: components["schemas"]["PageInfo"] & {
      items: components["schemas"]["ConnectedApp"][];
    };
    /** @description ConnectedApp provides an overview of all connections associated to an app for a given organisation. */
    ConnectedApp: {
      app: components["schemas"]["App"];
      connections: components["schemas"]["ConnectionOverview"][];
    };
    /**
     * @description ConnectionOverview provides minimal information on a connection. This information can be used to link through to
     * a connection details page via its ID.
     */
    ConnectionOverview: {
      id?: string;
      name: string;
    };
    ConnectionsPage: components["schemas"]["PageInfo"] & {
      items: components["schemas"]["Connection"][];
    };
    InitConnectionRequestBody: {
      appId: string;
      authType: string;
    };
    InitConnectionResponseBody: {
      action: components["schemas"]["InitConnectionAction"];
    };
    InitConnectionAction: {
      redirect?: components["schemas"]["InitConnectionActionRedirect"];
      form?: components["schemas"]["InitConnectionActionForm"];
    };
    /**
     * @description InitConnectionActionRedirect tells the user agent to redirect to the provided URL to complete the connection.
     * This is most likely to perform an OAuth2.0 authorization code grant, but there may be other protocols in the
     * future. In the case of an OAuth2.0 flow, the redirect URL will be back to switchboard to complete the connection
     * process, this will be transparent to the user.
     */
    InitConnectionActionRedirect: {
      /** @description The URL to redirect the user */
      url: string;
    };
    /**
     * @description InitConnectionActionForm tells the user agent to render a form requesting additional information from the user
     * such as api-key or basic-auth credentials.
     */
    InitConnectionActionForm: {
      /**
       * @description This is to be some kind of schema used to generate a HTML form. The exact details of this schema are not
       * known at the time of writing.
       */
      schema?: Record<string, never>;
    };
    /**
     * @description SchemaSignedURLResponseBody is the response to allow user-agents upload a schema to our internal storage and
     * provide a URL for use when creating the associated App.
     */
    SchemaSignedURLResponseBody: {
      /**
       * @description The URL used to upload the object, this includes parameters containing the signature of the ServiceAccount
       * which authorised the upload
       */
      uploadURL: string;
      /** @description The URL to identify the schema. This is not publicly accessible and is to be used when creating an App. */
      url: string;
    };
    /** @description SignedURLResponseBody is the response to allow user-agents to upload assets to our internal storage. */
    SignedURLResponseBody: {
      /**
       * @description The URL used to upload the object, this includes parameters containing the signature of the ServiceAccount
       * which authorised the upload
       */
      uploadURL: string;
      /** @description The URL to identify the asset. */
      url: string;
    };
    /**
     * @description CreateCredentialRequestBody is the request body to create a new credential. The ID is automatically generated
     * and the organisation ID is defined by the request's path parameter.
     */
    CreateCredentialRequestBody: {
      /** @description Name is the credential name. */
      name: string;
      /** @description Data is a map of string keys to string base64 encoded values for the actual credential data. */
      data: Record<string, never>;
      type: components["schemas"]["CredentialType"];
      /**
       * @description RedactFields is a list of fields within data which once created should not be returned to the user. This
       * property is only applicable for "Default" credential types. Credentials of other types have their own
       * redaction list internally and this field will be ignored.
       */
      redactFields?: string[];
      /**
       * Format: date-time
       * @description ExpiresAt allows the user to specify when Switchboard should automatically delete the credential.
       */
      expiresAt?: string;
    };
    /**
     * @description Type provides additional context to what data the credential contains. Certain types dictate that certain fields
     * must be set in order for the credential to be considered valid:
     *
     * - "Default" is the default type for a Credential. Data may contain arbitrary properties and will always be
     *   considered valid.
     * - "OAuth2Refresh" signifies the credential is to be used for issuing OAuth 2.0 access tokens based on a refresh
     *   token. The credential data must json-marshal into a CredentialDataOAuth2Refresh in order to be valid.
     *   Credentials of this type may only be created or updated via the connections APIs, not by the credentials APIs.
     * - "Raw" signifies the credential contains a value which can be used until the credential expires (or never if
     *   the credential has no expiry). The credential data must json-marshal into a CredentialDataRaw in order to be
     *   valid.
     * - "BasicAuth" signifies the credential contains credentials to be used in HTTP Basic authentication schemes. The
     *   credential data must json-marshal into a CredentialDataBasicAuth in order to be valid.
     */
    CredentialType: string;
    /** @description CredentialDataOAuth2Refresh holds the configuration required to issue access tokens from a refresh token. */
    CredentialDataOAuth2Refresh: {
      /** @description ClientID is the identifier for the OAuth2 client. */
      clientID: string;
      /** @description ClientSecret is the credential for the OAuth2 client. */
      clientSecret: string;
      /** @description TokenURL is where requests should be made to issue an access token in exchange for a refresh token. */
      tokenURL: string;
      /**
       * @description AuthStyle denotes how the client ID and secret should be sent to the token URL. The default is to
       * auto-detect.
       */
      authStyle?: string;
      /** @description RefreshToken is the token issued to the client when they manually authorise it. */
      refreshToken: string;
    };
    /**
     * @description CredentialDataRaw holds a single value which can be used to store an arbitrary secret like an API key or
     * password.
     */
    CredentialDataRaw: {
      /** @description Raw is the raw value which this credential manages */
      raw: string;
    };
    /** @description CredentialDataBasicAuth holds credentials to authenticate to a HTTP server protected by Basic Authentication. */
    CredentialDataBasicAuth: {
      /** @description Username is the basic-auth username. */
      username: string;
      /** @description Password is the basic-auth password. */
      password: string;
    };
    Server: {
      /**
       * @description Description is a human-friendly name for this server address. If a friendly name isn't available then this
       * defaults to the URL.
       */
      name: string;
      /** @description URL is the server address listening for requests. */
      url: string;
    };
    /**
     * @description Scopes is a map of scopes this API supports, with the scope name as keys and a description as the value.
     * It may not be required to specify them all to connect the App.
     */
    Scopes: Record<string, never>;
    PageInfo: {
      totalCount: number;
      next?: string;
      prev?: string;
    };
    /** @description BoardVariablesSchema is the schema definition for board variables. */
    BoardVariablesSchema: {
      dynamic?: components["schemas"]["VariablesSchema"];
      global?: components["schemas"]["VariablesSchema"];
    };
    VariablesSchema: Record<string, never>;
  };
  responses: {
    /** @description All information a hub user is required to provide to use an integration */
    ConnectIntegrationResponse: {
      content: {
        "application/json": components["schemas"]["ConnectIntegration"];
      };
    };
    /** @description A paginated set of Boards */
    GetBoardsResponse: {
      content: {
        "application/json": components["schemas"]["BoardsPage"];
      };
    };
    /** @description A paginated result of apps with associated ConnectionOverview data. */
    GetConnectedAppsResponse: {
      content: {
        "application/json": components["schemas"]["ConnectedAppsPage"];
      };
    };
    /** @description A paginated result of Apps. */
    GetConnectionsResponse: {
      content: {
        "application/json": components["schemas"]["ConnectionsPage"];
      };
    };
    /** @description A single Connection result. */
    CreateConnectionResponse: {
      content: {
        "application/json": components["schemas"]["Connection"];
      };
    };
    /** @description The configuration to initialise a new connection. */
    InitConnectionResponse: {
      content: {
        "application/json": components["schemas"]["InitConnectionResponseBody"];
      };
    };
    /** @description CreateCredentialResponse is the response containing the new credential. */
    CreateCredentialResponse: {
      content: {
        "application/json": components["schemas"]["Credential"];
      };
    };
    /** @description GetVariablesSchemaResponse is the response containing the variables schema. */
    GetVariablesSchemaResponse: {
      content: {
        "application/json": components["schemas"]["BoardVariablesSchema"];
      };
    };
    /** @description The default error response */
    ErrorResponse: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Responses for a User. */
    UserResponse: {
      content: {
        "application/json": components["schemas"]["User"];
      };
    };
  };
  parameters: {
    /**
     * @description SchemaType is the type of schema which an App implements. The only supported values are currently "openapi", but
     * is planned to be extended to include gRPC, GraphQL and SOAP.
     */
    SchemaType: string;
    SortParam?: string;
  };
  requestBodies: {
    /**
     * @description Payload for creating and updating a user.
     * On update the provided User overwrite the existing one.
     */
    CreateUser?: {
      content: {
        "application/json": components["schemas"]["User"];
      };
    };
    /** @description CreateConnectionRequest is the payload for creating a new Connection. */
    CreateConnectionRequest?: {
      content: {
        "application/json": components["schemas"]["CreateConnectionRequestBody"];
      };
    };
    /** @description The parameters to initialise a new connection */
    InitConnectionRequest?: {
      content: {
        "application/json": components["schemas"]["InitConnectionRequestBody"];
      };
    };
    /** @description CreateCredentialRequest is the request definition for creating a new credential. */
    CreateCredentialRequest?: {
      content: {
        "application/json": components["schemas"]["CreateCredentialRequestBody"];
      };
    };
  };
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** @description Get the JSON schema for the variables of a board. */
  GetBoardVariablesSchema: {
    parameters: {
      path: {
        /** @example 101 */
        organisationId: string;
        boardId: string;
      };
    };
    responses: {
      200: components["responses"]["GetVariablesSchemaResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** @description Retrieves the boards belonging to a given hub and organisation. */
  ListHubBoards: {
    parameters: {
      query?: {
        search?: string;
        first?: number;
        before?: string;
        after?: string;
        sort?: string;
      };
      path: {
        /** @example 101 */
        organisationId: string;
        hubId: string;
      };
    };
    responses: {
      200: components["responses"]["GetBoardsResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** @description Retrieves a pagniated list of boards belonging to a given user and hub. */
  GetUserHubBoards: {
    parameters: {
      query?: {
        search?: string;
        first?: number;
        before?: string;
        after?: string;
        sort?: string;
      };
      path: {
        /** @example 101 */
        organisationId: string;
        /** @example 101 */
        userId: string;
        hubId: string;
      };
    };
    responses: {
      200: components["responses"]["GetBoardsResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** @description Retrieves a page of Apps which have connections for an organisation. */
  GetConnectedApps: {
    parameters: {
      query?: {
        first?: number;
        before?: string;
        after?: string;
        sort?: components["parameters"]["SortParam"];
      };
      path: {
        /** @example 101 */
        organisationId: string;
      };
    };
    responses: {
      200: components["responses"]["GetConnectedAppsResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /**
   * @description Retrieves connections for an organisation, potentially filtering by appId. The response is structured as a page
   * but currently the response returns all items. Consumers wishing to be backwards compatible should not assume
   * this API will always return all items.
   */
  GetConnections: {
    parameters: {
      query?: {
        /**
         * @description Optionally filter connections by an App ID
         * @example 01FQ2PJ5QVA5H2A8J4V9ZA8NJS
         */
        appId?: string;
        first?: number;
        before?: string;
        after?: string;
        sort?: components["parameters"]["SortParam"];
      };
      path: {
        /** @example 101 */
        organisationId: string;
      };
    };
    responses: {
      200: components["responses"]["GetConnectionsResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /**
   * @description Creates a connection between an organisation and an App. This is to be used by authentication methods which the
   * user can explicitly configure, such as API Key and Basic Auth. For OAuth2/OIDC connections, users should call
   * the InitialiseConnection endpoint instead.
   */
  CreateConnection: {
    parameters: {
      path: {
        /** @example 101 */
        organisationId: string;
      };
    };
    requestBody: components["requestBodies"]["CreateConnectionRequest"];
    responses: {
      201: components["responses"]["CreateConnectionResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** @description Retrieves all the information needed that a user needs to fill out to use a Hub integration. */
  IntegrationInfo: {
    parameters: {
      path: {
        organisationId: string;
        hubId: string;
        boardId: string;
      };
    };
    responses: {
      200: components["responses"]["ConnectIntegrationResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /**
   * @description InitialiseConnection is used to initiate a connection of an App to a user's organisation. Different connections
   * require different auth methods (or even no auth method at all), this endpoint returns the necessary
   * configuration required to establish that connection.
   */
  InitialiseConnection: {
    parameters: {
      path: {
        /** @example 101 */
        organisationId: string;
      };
    };
    requestBody: components["requestBodies"]["InitConnectionRequest"];
    responses: {
      200: components["responses"]["InitConnectionResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /**
   * @description CreateCredential allows users to create new Credentials. Valid requests which return a credential marked as
   * "invalid" is normal behaviour, but the credential won't be usable until it's updated to become valid.
   */
  CreateCredential: {
    parameters: {
      path: {
        /** @example 101 */
        organisationId: string;
      };
    };
    requestBody: components["requestBodies"]["CreateCredentialRequest"];
    responses: {
      201: components["responses"]["CreateCredentialResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** @description Returns the user specified by the userId. */
  GetUser: {
    parameters: {
      path: {
        orgId: string;
        hubId: string;
        boardId: string;
        userId: string;
      };
    };
    responses: {
      200: components["responses"]["UserResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** @description Updates the given user. */
  PutUser: {
    parameters: {
      path: {
        orgId: string;
        hubId: string;
        boardId: string;
        userId: string;
      };
    };
    requestBody: components["requestBodies"]["CreateUser"];
    responses: {
      200: components["responses"]["UserResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** @description Create a new User. */
  PostUser: {
    parameters: {
      path: {
        orgId: string;
        hubId: string;
        boardId: string;
        userId: string;
      };
    };
    requestBody: components["requestBodies"]["CreateUser"];
    responses: {
      200: components["responses"]["UserResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /** @description Delete a user. */
  DeleteUser: {
    parameters: {
      path: {
        orgId: string;
        hubId: string;
        boardId: string;
        userId: string;
      };
    };
    responses: {
      200: components["responses"]["UserResponse"];
      default: components["responses"]["ErrorResponse"];
    };
  };
  /**
   * @description FinaliseConnectionCallback is the redirect URL to exchange an authorization code for an access token in an
   * OAuth2.0 authorization code grant. It must be noted that the real callback URL configured with the
   * OAuth2.0 provider should be a Switchboard URL (prompted to the user at app-creation time) and not this API URL.
   */
  FinaliseConnectionCallback: {
    parameters: {
      query?: {
        /** @description The authorization code to exchange for an access token. */
        code?: string;
        /**
         * @description This value is generated by the `/organisations/{organisationId}/connection-init` operation and is an opaque
         * string and should have no meaning to external clients. Internally, it's used to verify the flow was
         * initialised by Switchboard and connect the authorisation grant to the user/organisation who initiated it.
         */
        state?: string;
        /** @description An error code by the OAuth2.0 provider indicating a problem occurred during the grant. */
        error?: string;
        /** @description A human-readable error message associated to the error code specified in the `error` parameter. */
        error_description?: string;
      };
    };
    responses: {
      /**
       * @description The callback has been handled successfully, there is no response to this request. In a browser context, the
       * user should be redirected back to a suitable location.
       */
      204: {
        content: never;
      };
      default: components["responses"]["ErrorResponse"];
    };
  };
}
